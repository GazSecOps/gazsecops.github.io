<!doctype html><html lang=en><head><title>SSH Hardening: What Actually Matters :: Gareth's Engineering Blog</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content=" Sysadmin: I&rsquo;ve hardened SSH. Disabled root login, changed the port, installed fail2ban.
Engineer: Changed the port?
Sysadmin: Yeah, moved it to 2222. Security through obscurity.
Engineer: A port scan takes four seconds. What about certificate auth?
Sysadmin: What about what?
SSH hardening advice on the internet falls into two categories: the stuff that doesn&rsquo;t matter (change the port, install fail2ban, add a banner) and the stuff that does matter but nobody explains properly (certificate auth, key management, agent forwarding risks, auditing).
This post is about the second category.
The threat isn't someone brute-forcing your SSH port. It's the key that's been sitting in a developer's home directory since 2019, with no passphrase, copied to six machines. If you&rsquo;re running Linux servers - on-prem, cloud, doesn&rsquo;t matter - SSH is your management plane. If SSH is compromised, everything behind it is compromised. Treat it accordingly.
"><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://gazsecops.github.io/posts/ssh-hardening-what-actually-matters/><link rel=stylesheet href=https://gazsecops.github.io/css/extended.min.c658c723e006469d82f697e19c5338967fad12c57650bdd915bacf9cfbe2cc38.css><link rel=stylesheet href=https://gazsecops.github.io/css/buttons.min.86f6b4c106b6c6eb690ae5203d36b442c1f66f718ff4e8164fa86cf6c61ad641.css><link rel=stylesheet href=https://gazsecops.github.io/css/code.min.d529ea4b2fb8d34328d7d31afc5466d5f7bc2f0bc9abdd98b69385335d7baee4.css><link rel=stylesheet href=https://gazsecops.github.io/css/fonts.min.5bb7ed13e1d00d8ff39ea84af26737007eb5051b157b86fc24487c94f3dc8bbe.css><link rel=stylesheet href=https://gazsecops.github.io/css/footer.min.eb8dfc2c6a7eafa36cd3ba92d63e69e849e2200e0002a228d137f236b09ecd75.css><link rel=stylesheet href=https://gazsecops.github.io/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css><link rel=stylesheet href=https://gazsecops.github.io/css/header.min.75c7eb0e2872d95ff48109c6647d0223a38db52e2561dd87966eb5fc7c6bdac6.css><link rel=stylesheet href=https://gazsecops.github.io/css/main.min.36833afd348409fc6c3d09d0897c5833d9d5bf1ff31f5e60ea3ee42ce2b1268c.css><link rel=stylesheet href=https://gazsecops.github.io/css/menu.min.3c17467ebeb3d38663dce68f71f519901124fa5cbb4519b2fb0667a21e9aca39.css><link rel=stylesheet href=https://gazsecops.github.io/css/pagination.min.bbb986dbce00a5ce5aca0504b7925fc1c581992a4bf57f163e5d69cc1db7d836.css><link rel=stylesheet href=https://gazsecops.github.io/css/post.min.e6dddd258e64c83e05cec0cd49c05216742d42fc8ecbfbe6b67083412b609bd3.css><link rel=stylesheet href=https://gazsecops.github.io/css/syntax.min.a0773cce9310cb6d8ed23e50f005448facf29a53001b57e038828daa466b25c0.css><link rel=stylesheet href=https://gazsecops.github.io/css/terminal.min.e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css><link rel=stylesheet href=https://gazsecops.github.io/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css><link rel="shortcut icon" href=https://gazsecops.github.io/favicon.png><link rel=apple-touch-icon href=https://gazsecops.github.io/apple-touch-icon.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="SSH Hardening: What Actually Matters"><meta property="og:description" content=" Sysadmin: I&rsquo;ve hardened SSH. Disabled root login, changed the port, installed fail2ban.
Engineer: Changed the port?
Sysadmin: Yeah, moved it to 2222. Security through obscurity.
Engineer: A port scan takes four seconds. What about certificate auth?
Sysadmin: What about what?
SSH hardening advice on the internet falls into two categories: the stuff that doesn&rsquo;t matter (change the port, install fail2ban, add a banner) and the stuff that does matter but nobody explains properly (certificate auth, key management, agent forwarding risks, auditing).
This post is about the second category.
The threat isn't someone brute-forcing your SSH port. It's the key that's been sitting in a developer's home directory since 2019, with no passphrase, copied to six machines. If you&rsquo;re running Linux servers - on-prem, cloud, doesn&rsquo;t matter - SSH is your management plane. If SSH is compromised, everything behind it is compromised. Treat it accordingly.
"><meta property="og:url" content="https://gazsecops.github.io/posts/ssh-hardening-what-actually-matters/"><meta property="og:site_name" content="Gareth's Engineering Blog"><meta property="og:image" content="https://gazsecops.github.io/og-image.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><meta property="article:published_time" content="2025-03-18 10:00:00 +0000 UTC"></head><body><div class="container center"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>gareth@blog:~$</div></a></div><div class=header__search><input type=text id=header-search placeholder="Quick search..." style="padding:5px 10px;background:#222;color:#eee;border:1px solid #444;border-radius:3px;font-size:14px;width:200px"></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/topics/>Topics</a></li><li><a href=/posts/>All</a></li><li><a href=/series/>Series</a></li><li><a href=/tags/>Tags</a></li><li><a href=/archive/>Archive</a></li><li><a href=/search/>Search</a></li><li><a href=/about/>About</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/topics/>Topics</a></li><li><a href=/posts/>All</a></li><li><a href=/series/>Series</a></li><li><a href=/tags/>Tags</a></li><li><a href=/archive/>Archive</a></li><li><a href=/search/>Search</a></li><li><a href=/about/>About</a></li></ul></nav></header><script>(function(){const e=document.getElementById("header-search");if(!e)return;e.addEventListener("keydown",function(e){if(e.key==="Enter"){const e=this.value.trim();e&&(window.location.href="/search?q="+encodeURIComponent(e))}}),document.addEventListener("keydown",function(t){t.key==="/"&&!["INPUT","TEXTAREA"].includes(t.target.tagName)&&(t.preventDefault(),e.focus()),t.key==="Escape"&&t.target===e&&e.blur()})})()</script><style>.header__inner{display:flex;align-items:center;gap:20px}.header__search{flex:none}#header-search::placeholder{color:#666;font-style:italic}#header-search:focus{outline:none;border-color:#888}@media(max-width:684px){.header__search{display:none}}</style><div class=content><article class=post><h1 class=post-title><a href=https://gazsecops.github.io/posts/ssh-hardening-what-actually-matters/>SSH Hardening: What Actually Matters</a></h1><div class=post-meta><time class=post-date>2025-03-18</time><span class=post-author>Gareth</span><span class=post-reading-time>10 min read (2126 words)</span></div><span class=post-tags>#<a href=https://gazsecops.github.io/tags/security/>security</a>&nbsp;
#<a href=https://gazsecops.github.io/tags/ssh/>ssh</a>&nbsp;
#<a href=https://gazsecops.github.io/tags/linux/>linux</a>&nbsp;
#<a href=https://gazsecops.github.io/tags/operations/>operations</a>&nbsp;
#<a href=https://gazsecops.github.io/tags/hardening/>hardening</a>&nbsp;</span><div class=table-of-contents><h2>Table of Contents</h2><nav id=TableOfContents><ul><li><a href=#what-doesnt-matter-much>What Doesn&rsquo;t Matter (Much)</a></li><li><a href=#what-actually-matters>What Actually Matters</a><ul><li><a href=#1-key-based-auth-only-no-passwords>1. Key-based auth only. No passwords.</a></li><li><a href=#2-use-ed25519-keys>2. Use Ed25519 keys</a></li><li><a href=#3-passphrase-protect-your-keys>3. Passphrase-protect your keys</a></li><li><a href=#4-lock-down-sshd_config>4. Lock down sshd_config</a></li><li><a href=#5-authorized_keys-hygiene>5. authorized_keys hygiene</a></li><li><a href=#6-ssh-certificates-the-thing-most-people-skip>6. SSH certificates (the thing most people skip)</a></li><li><a href=#7-bastion--jump-host-patterns>7. Bastion / jump host patterns</a></li><li><a href=#8-audit-who-did-what>8. Audit: who did what</a></li></ul></li><li><a href=#cloud-ssh>Cloud SSH</a><ul><li><a href=#aws>AWS</a></li><li><a href=#azure>Azure</a></li><li><a href=#gcp>GCP</a></li></ul></li><li><a href=#what-breaks>What Breaks</a><ul><li><a href=#old-keys-nobody-removes>Old keys nobody removes</a></li><li><a href=#shared-keys>Shared keys</a></li><li><a href=#agent-forwarding-to-untrusted-hosts>Agent forwarding to untrusted hosts</a></li><li><a href=#stale-known_hosts>Stale known_hosts</a></li></ul></li><li><a href=#the-boring-truth>The Boring Truth</a></li></ul></nav></div><div class=post-content><div><div class=dialogue><p><span class="speaker speaker-sysadmin">Sysadmin:</span> I&rsquo;ve hardened SSH. Disabled root login, changed the port, installed fail2ban.</p><p><span class="speaker speaker-engineer">Engineer:</span> Changed the port?</p><p><span class="speaker speaker-sysadmin">Sysadmin:</span> Yeah, moved it to 2222. Security through obscurity.</p><p><span class="speaker speaker-engineer">Engineer:</span> A port scan takes four seconds. What about certificate auth?</p><p><span class="speaker speaker-sysadmin">Sysadmin:</span> What about what?</p></div><p>SSH hardening advice on the internet falls into two categories: the stuff that doesn&rsquo;t matter (change the port, install fail2ban, add a banner) and the stuff that does matter but nobody explains properly (certificate auth, key management, agent forwarding risks, auditing).</p><p>This post is about the second category.</p><aside class=pullquote>The threat isn't someone brute-forcing your SSH port. It's the key that's been sitting in a developer's home directory since 2019, with no passphrase, copied to six machines.</aside><p>If you&rsquo;re running Linux servers - on-prem, cloud, doesn&rsquo;t matter - SSH is your management plane. If SSH is compromised, everything behind it is compromised. Treat it accordingly.</p><h2 id=what-doesnt-matter-much>What Doesn&rsquo;t Matter (Much)<a href=#what-doesnt-matter-much class=hanchor arialabel=Anchor>#</a></h2><p>Get these out of the way so we can focus on what does.</p><p><strong>Changing the port:</strong> Stops automated scanners. Doesn&rsquo;t stop anyone who&rsquo;s actually targeting you. A full port scan takes seconds. If this is your hardening strategy, you don&rsquo;t have a hardening strategy.</p><p><strong>Login banners:</strong> Legal requirement in some jurisdictions. Zero security value. Nobody has ever been stopped by &ldquo;Unauthorised access is prohibited&rdquo;.</p><p><strong>fail2ban (alone):</strong> Bans IPs after failed attempts. Fine for reducing log noise. Useless against an attacker using a botnet with thousands of IPs, or one who has a valid key.</p><p>These aren&rsquo;t harmful. They&rsquo;re just not where the risk is.</p><h2 id=what-actually-matters>What Actually Matters<a href=#what-actually-matters class=hanchor arialabel=Anchor>#</a></h2><h3 id=1-key-based-auth-only-no-passwords>1. Key-based auth only. No passwords.<a href=#1-key-based-auth-only-no-passwords class=hanchor arialabel=Anchor>#</a></h3><p>This is the minimum. If you still allow password auth over SSH, fix that first before reading the rest.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-fallback data-lang=fallback><span style=display:flex><span># /etc/ssh/sshd_config
</span></span><span style=display:flex><span>PasswordAuthentication no
</span></span><span style=display:flex><span>KbdInteractiveAuthentication no
</span></span><span style=display:flex><span>UsePAM yes
</span></span></code></pre></div><p>Keep <code>UsePAM yes</code> for session management and account controls, but make sure PAM isn&rsquo;t configured to fall back to password auth for SSH.</p><p>Why this matters: password auth is brute-forceable. Key auth isn&rsquo;t (assuming reasonable key sizes). A 4096-bit RSA key or an Ed25519 key is not getting brute-forced.</p><h3 id=2-use-ed25519-keys>2. Use Ed25519 keys<a href=#2-use-ed25519-keys class=hanchor arialabel=Anchor>#</a></h3><p>RSA works. Ed25519 is better.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>ssh-keygen -t ed25519 -C <span style=color:#e6db74>&#34;you@hostname&#34;</span>
</span></span></code></pre></div><p>Ed25519 keys are:</p><ul><li>Smaller (68 characters vs 400+ for RSA 4096)</li><li>Faster to verify</li><li>Not susceptible to the same implementation pitfalls as ECDSA (no random number problems)</li><li>Supported everywhere that matters (OpenSSH 6.5+, which is ancient now)</li></ul><p>If you need RSA for compatibility with something old, use 4096-bit minimum. If you&rsquo;re generating 2048-bit RSA keys in 2025, stop.</p><h3 id=3-passphrase-protect-your-keys>3. Passphrase-protect your keys<a href=#3-passphrase-protect-your-keys class=hanchor arialabel=Anchor>#</a></h3><p>A private key without a passphrase is a plaintext credential sitting on disk.</p><p>If someone gets access to a developer&rsquo;s laptop - stolen, malware, whatever - an unprotected private key gives them access to every server that trusts it.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># Add passphrase to existing key</span>
</span></span><span style=display:flex><span>ssh-keygen -p -f ~/.ssh/id_ed25519
</span></span></code></pre></div><p>Use <code>ssh-agent</code> so you don&rsquo;t have to type it every time:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>eval <span style=color:#e6db74>&#34;</span><span style=color:#66d9ef>$(</span>ssh-agent -s<span style=color:#66d9ef>)</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>ssh-add ~/.ssh/id_ed25519
</span></span></code></pre></div><p>The agent holds the decrypted key in memory for the session. You type the passphrase once. The key on disk stays encrypted.</p><h3 id=4-lock-down-sshd_config>4. Lock down sshd_config<a href=#4-lock-down-sshd_config class=hanchor arialabel=Anchor>#</a></h3><p>A sane baseline:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-fallback data-lang=fallback><span style=display:flex><span># Authentication
</span></span><span style=display:flex><span>PermitRootLogin no
</span></span><span style=display:flex><span>PasswordAuthentication no
</span></span><span style=display:flex><span>KbdInteractiveAuthentication no
</span></span><span style=display:flex><span>PubkeyAuthentication yes
</span></span><span style=display:flex><span>AuthorizedKeysFile .ssh/authorized_keys
</span></span><span style=display:flex><span>MaxAuthTries 3
</span></span><span style=display:flex><span>AuthenticationMethods publickey
</span></span><span style=display:flex><span>PermitEmptyPasswords no
</span></span><span style=display:flex><span>PermitUserEnvironment no
</span></span><span style=display:flex><span>StrictModes yes
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span># Restrict users
</span></span><span style=display:flex><span>AllowUsers deploy monitoring admin
</span></span><span style=display:flex><span># Or use groups:
</span></span><span style=display:flex><span># AllowGroups ssh-users
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span># Network
</span></span><span style=display:flex><span>ListenAddress 10.0.1.5
</span></span><span style=display:flex><span>AddressFamily inet
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span># Session
</span></span><span style=display:flex><span>ClientAliveInterval 300
</span></span><span style=display:flex><span>ClientAliveCountMax 2
</span></span><span style=display:flex><span>MaxSessions 3
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span># Forwarding (disable what you don&#39;t need)
</span></span><span style=display:flex><span>AllowTcpForwarding no
</span></span><span style=display:flex><span>AllowAgentForwarding no
</span></span><span style=display:flex><span>X11Forwarding no
</span></span><span style=display:flex><span>GatewayPorts no
</span></span><span style=display:flex><span>PermitTunnel no
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span># Crypto
</span></span><span style=display:flex><span>KexAlgorithms curve25519-sha256,curve25519-sha256@libssh.org
</span></span><span style=display:flex><span>Ciphers chacha20-poly1305@openssh.com,aes256-gcm@openssh.com,aes128-gcm@openssh.com
</span></span><span style=display:flex><span>MACs hmac-sha2-256-etm@openssh.com,hmac-sha2-512-etm@openssh.com
</span></span><span style=display:flex><span>HostKeyAlgorithms ssh-ed25519,rsa-sha2-512,rsa-sha2-256
</span></span></code></pre></div><p>Notes:</p><ul><li><code>PermitRootLogin no</code> - always. Use sudo.</li><li><code>AllowUsers</code> or <code>AllowGroups</code> - explicit allowlist. If you&rsquo;re not on the list, you don&rsquo;t connect. Full stop.</li><li><code>ListenAddress</code> - bind to the management interface, not 0.0.0.0</li><li>Forwarding defaults to off. Enable per-user or per-host only where needed.</li><li>Crypto choices drop everything weak. If something can&rsquo;t connect with these, it&rsquo;s old enough to be a problem itself.</li></ul><p>If you&rsquo;re on a modern distro, prefer drop-in config instead of editing the main file:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>/etc/ssh/sshd_config.d/10-hardening.conf
</span></span></code></pre></div><p>And to see the effective config (after includes and defaults):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>sshd -T | sort
</span></span></code></pre></div><p>After changing sshd_config, always:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>sshd -t  <span style=color:#75715e># test config before reloading</span>
</span></span><span style=display:flex><span>systemctl reload sshd
</span></span></code></pre></div><p>And keep your existing session open until you&rsquo;ve confirmed the new config works. Locking yourself out of your own server is a rite of passage, but only the first time.</p><h3 id=5-authorized_keys-hygiene>5. authorized_keys hygiene<a href=#5-authorized_keys-hygiene class=hanchor arialabel=Anchor>#</a></h3><p>This is where most SSH deployments rot.</p><p><code>~/.ssh/authorized_keys</code> accumulates keys over time. People leave. Keys aren&rsquo;t removed. Nobody audits.</p><p><strong>Problems:</strong></p><ul><li>Ex-employees still have access</li><li>Keys copied between machines (one compromised key opens many doors)</li><li>No way to tell which key belongs to whom without comments</li><li>No expiry</li></ul><p><strong>Minimum hygiene:</strong></p><ul><li>Every key gets a comment identifying the owner and purpose</li><li>Review authorized_keys quarterly (automate this)</li><li>Remove keys for anyone who&rsquo;s left or changed role</li><li>One key per person per use case (don&rsquo;t reuse keys across purposes)</li></ul><p>Also: file permissions matter. If your <code>.ssh</code> directory is writable by group/other, sshd will ignore it (or should).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>chmod <span style=color:#ae81ff>700</span> ~/.ssh
</span></span><span style=display:flex><span>chmod <span style=color:#ae81ff>600</span> ~/.ssh/authorized_keys
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># Audit: show fingerprints and comments</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> keyfile in /home/*/.ssh/authorized_keys; <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>[</span> -f <span style=color:#e6db74>&#34;</span>$keyfile<span style=color:#e6db74>&#34;</span> <span style=color:#f92672>]</span> <span style=color:#f92672>||</span> <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>    echo <span style=color:#e6db74>&#34;=== </span>$keyfile<span style=color:#e6db74> ===&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> IFS<span style=color:#f92672>=</span> read -r line; <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># Skip blanks and comments</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>[</span> -z <span style=color:#e6db74>&#34;</span>$line<span style=color:#e6db74>&#34;</span> <span style=color:#f92672>]</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#34;</span>$line<span style=color:#e6db74>&#34;</span> in
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>\#</span>*<span style=color:#f92672>)</span> <span style=color:#66d9ef>continue</span> ;;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>esac</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># Print fingerprint and comment for each key line</span>
</span></span><span style=display:flex><span>        fp<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>printf <span style=color:#e6db74>&#39;%s\n&#39;</span> <span style=color:#e6db74>&#34;</span>$line<span style=color:#e6db74>&#34;</span> | ssh-keygen -lf /dev/stdin 2&gt;/dev/null | awk <span style=color:#e6db74>&#39;{print $2}&#39;</span><span style=color:#66d9ef>)</span>
</span></span><span style=display:flex><span>        comment<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>printf <span style=color:#e6db74>&#39;%s\n&#39;</span> <span style=color:#e6db74>&#34;</span>$line<span style=color:#e6db74>&#34;</span> | awk <span style=color:#e6db74>&#39;{print $NF}&#39;</span><span style=color:#66d9ef>)</span>
</span></span><span style=display:flex><span>        echo <span style=color:#e6db74>&#34;</span>$fp<span style=color:#e6db74>  </span>$comment<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>done</span> &lt; <span style=color:#e6db74>&#34;</span>$keyfile<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>done</span>
</span></span></code></pre></div><p>Run that on every server. You&rsquo;ll find keys you can&rsquo;t explain. Remove them.</p><h3 id=6-ssh-certificates-the-thing-most-people-skip>6. SSH certificates (the thing most people skip)<a href=#6-ssh-certificates-the-thing-most-people-skip class=hanchor arialabel=Anchor>#</a></h3><p>SSH certificates solve the authorized_keys problem properly.</p><p>Instead of distributing public keys to every server, you:</p><ol><li>Run an SSH CA (just a key pair, not complicated)</li><li>Sign user keys with the CA</li><li>Servers trust the CA, not individual keys</li><li>Certificates have an expiry</li></ol><p><strong>Set up a CA:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># Generate CA key (keep this safe - offline if possible)</span>
</span></span><span style=display:flex><span>ssh-keygen -t ed25519 -f /etc/ssh/ca_user_key -C <span style=color:#e6db74>&#34;SSH User CA&#34;</span>
</span></span></code></pre></div><p><strong>Sign a user&rsquo;s key:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># Sign for 8 hours, restrict to specific principals</span>
</span></span><span style=display:flex><span>ssh-keygen -s /etc/ssh/ca_user_key <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>    -I <span style=color:#e6db74>&#34;alice-laptop&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>    -n alice,deploy <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>    -V +8h <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>    alice_id_ed25519.pub
</span></span></code></pre></div><p>This creates <code>alice_id_ed25519-cert.pub</code> - a certificate that:</p><ul><li>Is valid for 8 hours</li><li>Identifies as &ldquo;alice-laptop&rdquo;</li><li>Allows login as <code>alice</code> or <code>deploy</code></li><li>Is signed by your CA</li></ul><p><strong>Configure servers to trust the CA:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-fallback data-lang=fallback><span style=display:flex><span># /etc/ssh/sshd_config
</span></span><span style=display:flex><span>TrustedUserCAKeys /etc/ssh/ca_user_key.pub
</span></span></code></pre></div><p>Now any key signed by your CA is trusted. No authorized_keys file needed. When the certificate expires, access stops. When someone leaves, stop signing their keys. Done.</p><p><strong>Why this is better:</strong></p><ul><li>No authorized_keys sprawl</li><li>Certificates expire (short-lived = less risk)</li><li>Centralised control (revoke by not re-signing)</li><li>Audit trail (who signed what, when, for how long)</li><li>Principals restrict which accounts a cert can access</li></ul><p>If you want this automated, <code>step-ca</code> can issue SSH certificates alongside TLS ones. See the <a href=/posts/stepca-running-internal-pki/>step-ca post</a> for the setup.</p><p><strong>Host certificates (fixes known_hosts rot):</strong></p><p>You can also sign server host keys, so clients trust the host CA instead of &ldquo;type yes to trust this random new key&rdquo;.</p><p>Create a host CA (offline if you can):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>ssh-keygen -t ed25519 -f /etc/ssh/ca_host_key -C <span style=color:#e6db74>&#34;SSH Host CA&#34;</span>
</span></span></code></pre></div><p>Sign a host key (run on the CA machine):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>ssh-keygen -s /etc/ssh/ca_host_key <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  -I <span style=color:#e6db74>&#34;host-internal-db01&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  -h <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  -n internal-db01,internal-db01.internal <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  -V +52w <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  /etc/ssh/ssh_host_ed25519_key.pub
</span></span></code></pre></div><p>On the server, point sshd at the host certificate:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span># /etc/ssh/sshd_config
</span></span><span style=display:flex><span>HostCertificate /etc/ssh/ssh_host_ed25519_key-cert.pub
</span></span></code></pre></div><p>On the client side, trust the host CA once:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span># ~/.ssh/known_hosts
</span></span><span style=display:flex><span>@cert-authority *.internal ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAA...host-ca-public...
</span></span></code></pre></div><p>This is the difference between &ldquo;TOFU forever&rdquo; and &ldquo;hosts are authenticated like grown-ups&rdquo;.</p><h3 id=7-bastion--jump-host-patterns>7. Bastion / jump host patterns<a href=#7-bastion--jump-host-patterns class=hanchor arialabel=Anchor>#</a></h3><p>Don&rsquo;t expose SSH on every server to the internet. Or even to your whole internal network.</p><p><strong>Pattern: bastion host</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-fallback data-lang=fallback><span style=display:flex><span>[You] --&gt; [Bastion] --&gt; [Internal servers]
</span></span></code></pre></div><ul><li>Bastion is the only host with SSH exposed</li><li>Internal servers only accept SSH from the bastion</li><li>Bastion logs everything</li><li>Bastion has no other purpose (no apps, no data)</li></ul><p><strong>SSH config for jumping through a bastion:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-fallback data-lang=fallback><span style=display:flex><span># ~/.ssh/config
</span></span><span style=display:flex><span>Host bastion
</span></span><span style=display:flex><span>    HostName bastion.example.com
</span></span><span style=display:flex><span>    User admin
</span></span><span style=display:flex><span>    IdentityFile ~/.ssh/id_ed25519
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Host internal-*
</span></span><span style=display:flex><span>    ProxyJump bastion
</span></span><span style=display:flex><span>    User deploy
</span></span><span style=display:flex><span>    IdentityFile ~/.ssh/id_ed25519
</span></span></code></pre></div><p>Now <code>ssh internal-db01</code> automatically jumps through the bastion. No manual two-step.</p><p><strong>ProxyJump vs agent forwarding:</strong></p><p>Use <code>ProxyJump</code>. Don&rsquo;t use agent forwarding.</p><p>Agent forwarding (<code>ssh -A</code>) puts your SSH agent socket on the remote host. Anyone with root on that host can use your agent to authenticate as you to other systems.</p><p>ProxyJump tunnels the connection through the bastion without exposing your agent. Same result, none of the risk.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-fallback data-lang=fallback><span style=display:flex><span># Bad: agent forwarding
</span></span><span style=display:flex><span>ssh -A bastion
</span></span><span style=display:flex><span>ssh internal-db01  # bastion admin could hijack your agent
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span># Good: ProxyJump
</span></span><span style=display:flex><span>ssh -J bastion internal-db01  # agent never touches bastion
</span></span></code></pre></div><p>If you have <code>AllowAgentForwarding yes</code> in your sshd_config and you don&rsquo;t have a specific reason for it, turn it off.</p><h3 id=8-audit-who-did-what>8. Audit: who did what<a href=#8-audit-who-did-what class=hanchor arialabel=Anchor>#</a></h3><p>SSH access without audit logging is access without accountability.</p><p><strong>sshd logging:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-fallback data-lang=fallback><span style=display:flex><span># /etc/ssh/sshd_config
</span></span><span style=display:flex><span>LogLevel VERBOSE
</span></span></code></pre></div><p><code>VERBOSE</code> logs key fingerprints on auth. You can tie a login to a specific key. <code>INFO</code> (the default) doesn&rsquo;t.</p><p><strong>Session logging with auditd:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># Watch for changes to SSH config</span>
</span></span><span style=display:flex><span>auditctl -w /etc/ssh/sshd_config -p wa -k sshd_config
</span></span><span style=display:flex><span>auditctl -w /etc/ssh/sshd_config.d -p wa -k sshd_config
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Watch for changes to authorised keys (pick the paths that exist in your environment)</span>
</span></span><span style=display:flex><span>auditctl -w /home -p wa -k ssh_authorized_keys
</span></span><span style=display:flex><span>auditctl -w /root/.ssh -p wa -k ssh_authorized_keys
</span></span></code></pre></div><p>Command logging via <code>execve</code> is possible, but it&rsquo;s noisy and it captures everything (including secrets in command lines). If you need session recording, use a tool designed for it and test the storage/retention.</p><p>To query audit events:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>ausearch -k sshd_config -i | less
</span></span><span style=display:flex><span>ausearch -k ssh_authorized_keys -i | less
</span></span></code></pre></div><p><strong>What to send to your log collector:</strong></p><ul><li>Authentication events (success and failure)</li><li>Key fingerprints (which key was used)</li><li>Source IPs</li><li>Session start/end</li><li>Commands executed (if your policy requires it)</li></ul><p>If someone compromises a server via SSH, you need to answer: which key, from which IP, at what time, and what did they do? Without audit logging, you&rsquo;re guessing.</p><h2 id=cloud-ssh>Cloud SSH<a href=#cloud-ssh class=hanchor arialabel=Anchor>#</a></h2><p>Cloud providers add their own wrinkles.</p><h3 id=aws>AWS<a href=#aws class=hanchor arialabel=Anchor>#</a></h3><ul><li>Use EC2 Instance Connect or SSM Session Manager instead of direct SSH where you can</li><li>If you use SSH keys, rotate them (AWS doesn&rsquo;t do this for you)</li><li>Security groups should restrict SSH to bastion or VPN, not 0.0.0.0/0</li><li>Use IMDSv2 (hop limit 1) so a compromised app can&rsquo;t grab instance credentials and pivot</li></ul><h3 id=azure>Azure<a href=#azure class=hanchor arialabel=Anchor>#</a></h3><ul><li>Azure Bastion provides browser-based SSH without exposing port 22</li><li>Microsoft Entra ID SSH login lets you authenticate with your corporate identity instead of keys</li><li>NSG rules should restrict SSH source IPs</li><li>Just-in-time VM access opens the port only when needed</li></ul><h3 id=gcp>GCP<a href=#gcp class=hanchor arialabel=Anchor>#</a></h3><ul><li>OS Login ties SSH to Google identities (no manual key management)</li><li>IAP (Identity-Aware Proxy) tunnels SSH through Google&rsquo;s infrastructure without exposing port 22</li><li>Use OS Login over project-wide SSH keys (project keys are a shared credential problem)</li></ul><p>The pattern is the same everywhere: don&rsquo;t expose SSH to the internet, use identity-based auth where you can, and audit everything.</p><h2 id=what-breaks>What Breaks<a href=#what-breaks class=hanchor arialabel=Anchor>#</a></h2><h3 id=old-keys-nobody-removes>Old keys nobody removes<a href=#old-keys-nobody-removes class=hanchor arialabel=Anchor>#</a></h3><p>The number one SSH security problem. Someone leaves the company. Their key stays in authorized_keys on thirty servers. Nobody notices.</p><p>Fix: SSH certificates (they expire) or automated authorized_keys management (pull from a central source, remove stale keys).</p><h3 id=shared-keys>Shared keys<a href=#shared-keys class=hanchor arialabel=Anchor>#</a></h3><p>A &ldquo;deploy key&rdquo; used by twelve people and three CI systems. Stored in a shared drive. Copied to laptops. No passphrase.</p><p>If this key is compromised, which it probably already is, you don&rsquo;t know who used it for what.</p><p>Fix: one key per person, one key per service. Certificate auth if you can.</p><h3 id=agent-forwarding-to-untrusted-hosts>Agent forwarding to untrusted hosts<a href=#agent-forwarding-to-untrusted-hosts class=hanchor arialabel=Anchor>#</a></h3><p>Developers SSH to a shared dev box with agent forwarding. Root on the dev box can hijack their agent and access production.</p><p>Fix: ProxyJump. Turn off AllowAgentForwarding.</p><h3 id=stale-known_hosts>Stale known_hosts<a href=#stale-known_hosts class=hanchor arialabel=Anchor>#</a></h3><p>Server gets rebuilt. Host key changes. Someone types &ldquo;yes&rdquo; without thinking. Now they might be connecting to the wrong thing.</p><p>Fix: host certificates (servers get certs signed by a CA, clients trust the CA, no more TOFU). Or at minimum, distribute known_hosts centrally.</p><h2 id=the-boring-truth>The Boring Truth<a href=#the-boring-truth class=hanchor arialabel=Anchor>#</a></h2><p>SSH hardening is not about changing the port or installing fancy tools. It&rsquo;s about:</p><ul><li>Key management (who has keys, where, and are they protected?)</li><li>Access control (who can connect to what, and is it the minimum needed?)</li><li>Certificates (if you can, because they solve the lifecycle problem)</li><li>Audit (who connected, with which key, and what did they do?)</li><li>Bastion patterns (reduce the attack surface to one well-monitored entry point)</li></ul><p>None of this is exciting. All of it matters more than the port number.</p><hr><p><em>For the PKI side of SSH certificates and how to automate issuance, see the <a href=/posts/stepca-running-internal-pki/>step-ca post</a>. For incident response when SSH access is compromised, the <a href=/posts/incident-response-what-actually-works/>IR post</a> covers containment and investigation. For monitoring the signals that tell you something&rsquo;s wrong, see the <a href=/posts/prometheus-security-monitoring/>Prometheus post</a>.</em></p></div></div><div class=related-posts style="margin-top:3rem;padding-top:2rem;border-top:1px solid #333"><h3>Related Posts</h3><ul style=list-style:none;padding:0><li style=margin-bottom:1rem><a href=https://gazsecops.github.io/posts/stepca-running-internal-pki/>Smallstep step-ca: Running Internal PKI Without Losing Your Mind</a>
<span style=color:#999;font-size:.9rem>- 28 Oct 2025</span><div style=font-size:.85rem;color:#666;margin-top:.25rem><span style=margin-right:.5rem>#security</span>
<span style=margin-right:.5rem>#pki</span>
<span style=margin-right:.5rem>#tls</span>
<span style=margin-right:.5rem>#certificates</span>
<span style=margin-right:.5rem>#linux</span>
<span style=margin-right:.5rem>#cloud</span>
<span style=margin-right:.5rem>#operations</span></div></li><li style=margin-bottom:1rem><a href=https://gazsecops.github.io/posts/incident-response-what-actually-works/>Incident Response: What Actually Works at 3am</a>
<span style=color:#999;font-size:.9rem>- 2 Jul 2025</span><div style=font-size:.85rem;color:#666;margin-top:.25rem><span style=margin-right:.5rem>#security</span>
<span style=margin-right:.5rem>#incident-response</span>
<span style=margin-right:.5rem>#operations</span>
<span style=margin-right:.5rem>#linux</span>
<span style=margin-right:.5rem>#cloud</span></div></li><li style=margin-bottom:1rem><a href=https://gazsecops.github.io/posts/dns-security-what-actually-breaks/>DNS Security: What Actually Breaks</a>
<span style=color:#999;font-size:.9rem>- 12 Jun 2025</span><div style=font-size:.85rem;color:#666;margin-top:.25rem><span style=margin-right:.5rem>#security</span>
<span style=margin-right:.5rem>#dns</span>
<span style=margin-right:.5rem>#linux</span>
<span style=margin-right:.5rem>#cloud</span>
<span style=margin-right:.5rem>#monitoring</span>
<span style=margin-right:.5rem>#operations</span>
<span style=margin-right:.5rem>#incident-response</span></div></li><li style=margin-bottom:1rem><a href=https://gazsecops.github.io/posts/password-managers-2025/>Password Managers in 2025: What Actually Works</a>
<span style=color:#999;font-size:.9rem>- 15 Apr 2025</span><div style=font-size:.85rem;color:#666;margin-top:.25rem><span style=margin-right:.5rem>#security</span>
<span style=margin-right:.5rem>#passwords</span>
<span style=margin-right:.5rem>#vault</span>
<span style=margin-right:.5rem>#linux</span>
<span style=margin-right:.5rem>#operations</span></div></li><li style=margin-bottom:1rem><a href=https://gazsecops.github.io/posts/bash-security-operators-guide/>Bash: The Swiss Army Knife for Security Professionals</a>
<span style=color:#999;font-size:.9rem>- 3 Dec 2024</span><div style=font-size:.85rem;color:#666;margin-top:.25rem><span style=margin-right:.5rem>#bash</span>
<span style=margin-right:.5rem>#security</span>
<span style=margin-right:.5rem>#red-team</span>
<span style=margin-right:.5rem>#blue-team</span>
<span style=margin-right:.5rem>#linux</span>
<span style=margin-right:.5rem>#operations</span></div></li></ul></div><div class=pagination><div class=pagination__title><span class=pagination__title-h></span><hr></div><div class=pagination__buttons><a href=https://gazsecops.github.io/posts/password-managers-2025/ class="button inline prev">&lt; [<span class=button__text>Password Managers in 2025: What Actually Works</span>]
</a>::
<a href=https://gazsecops.github.io/posts/confidential-computing-encrypted-data-processing/ class="button inline next">[<span class=button__text>Confidential Computing: Processing Data While Keeping It Secret</span>] ></a></div></div></article></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2026</span></div><div class=build-info><span class=build-commit>e733073</span><span class=build-date>2026-02-12 12:33 UTC</span></div></div></footer></div></body></html>