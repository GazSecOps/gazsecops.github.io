<!doctype html><html lang=en><head><title>Workload Identity: Giving Your Services an Identity Without the Secret Sprawl :: Gareth's Engineering Blog</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content=" Engineer: The database connection is failing.
Sysadmin: Check the credentials in the config.
Engineer: Which config? There are twelve.
Sysadmin: The one with the password that expires every 90 days.
Engineer: That expired yesterday. Nobody told me.
Sysadmin: Did you check the rotation runbook?
Engineer: The runbook is in a wiki that requires the database to log in.
Service accounts. API keys. Connection strings. Database passwords scattered across config files, environment variables, Kubernetes secrets, and that one spreadsheet someone maintains &ldquo;just in case&rdquo;. This is how most organisations handle non-human identity. It&rsquo;s also how most organisations get compromised.
Every hardcoded credential is a future incident waiting to happen. The question isn't whether it leaks - it's whether you notice when it does. Workload identity is about giving your services proper identities without the secret sprawl. Not another password to rotate. Not another API key to revoke when it appears in a GitHub commit. An identity that your infrastructure manages, rotates, and revokes automatically.
This post covers what workload identity actually means, how to implement it on major clouds and on-prem, and the practical patterns that make it survivable.
"><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://gazsecops.github.io/posts/workload-identity-beyond-api-keys/><link rel=stylesheet href=https://gazsecops.github.io/css/extended.min.c658c723e006469d82f697e19c5338967fad12c57650bdd915bacf9cfbe2cc38.css><link rel=stylesheet href=https://gazsecops.github.io/css/buttons.min.86f6b4c106b6c6eb690ae5203d36b442c1f66f718ff4e8164fa86cf6c61ad641.css><link rel=stylesheet href=https://gazsecops.github.io/css/code.min.d529ea4b2fb8d34328d7d31afc5466d5f7bc2f0bc9abdd98b69385335d7baee4.css><link rel=stylesheet href=https://gazsecops.github.io/css/fonts.min.5bb7ed13e1d00d8ff39ea84af26737007eb5051b157b86fc24487c94f3dc8bbe.css><link rel=stylesheet href=https://gazsecops.github.io/css/footer.min.eb8dfc2c6a7eafa36cd3ba92d63e69e849e2200e0002a228d137f236b09ecd75.css><link rel=stylesheet href=https://gazsecops.github.io/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css><link rel=stylesheet href=https://gazsecops.github.io/css/header.min.75c7eb0e2872d95ff48109c6647d0223a38db52e2561dd87966eb5fc7c6bdac6.css><link rel=stylesheet href=https://gazsecops.github.io/css/main.min.36833afd348409fc6c3d09d0897c5833d9d5bf1ff31f5e60ea3ee42ce2b1268c.css><link rel=stylesheet href=https://gazsecops.github.io/css/menu.min.3c17467ebeb3d38663dce68f71f519901124fa5cbb4519b2fb0667a21e9aca39.css><link rel=stylesheet href=https://gazsecops.github.io/css/pagination.min.bbb986dbce00a5ce5aca0504b7925fc1c581992a4bf57f163e5d69cc1db7d836.css><link rel=stylesheet href=https://gazsecops.github.io/css/post.min.e6dddd258e64c83e05cec0cd49c05216742d42fc8ecbfbe6b67083412b609bd3.css><link rel=stylesheet href=https://gazsecops.github.io/css/syntax.min.a0773cce9310cb6d8ed23e50f005448facf29a53001b57e038828daa466b25c0.css><link rel=stylesheet href=https://gazsecops.github.io/css/terminal.min.e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css><link rel=stylesheet href=https://gazsecops.github.io/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css><link rel="shortcut icon" href=https://gazsecops.github.io/favicon.png><link rel=apple-touch-icon href=https://gazsecops.github.io/apple-touch-icon.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Workload Identity: Giving Your Services an Identity Without the Secret Sprawl"><meta property="og:description" content=" Engineer: The database connection is failing.
Sysadmin: Check the credentials in the config.
Engineer: Which config? There are twelve.
Sysadmin: The one with the password that expires every 90 days.
Engineer: That expired yesterday. Nobody told me.
Sysadmin: Did you check the rotation runbook?
Engineer: The runbook is in a wiki that requires the database to log in.
Service accounts. API keys. Connection strings. Database passwords scattered across config files, environment variables, Kubernetes secrets, and that one spreadsheet someone maintains &ldquo;just in case&rdquo;. This is how most organisations handle non-human identity. It&rsquo;s also how most organisations get compromised.
Every hardcoded credential is a future incident waiting to happen. The question isn't whether it leaks - it's whether you notice when it does. Workload identity is about giving your services proper identities without the secret sprawl. Not another password to rotate. Not another API key to revoke when it appears in a GitHub commit. An identity that your infrastructure manages, rotates, and revokes automatically.
This post covers what workload identity actually means, how to implement it on major clouds and on-prem, and the practical patterns that make it survivable.
"><meta property="og:url" content="https://gazsecops.github.io/posts/workload-identity-beyond-api-keys/"><meta property="og:site_name" content="Gareth's Engineering Blog"><meta property="og:image" content="https://gazsecops.github.io/og-image.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><meta property="article:published_time" content="2026-02-08 10:00:00 +0000 UTC"></head><body><div class="container center"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>gareth@blog:~$</div></a></div><div class=header__search><input type=text id=header-search placeholder="Quick search..." style="padding:5px 10px;background:#222;color:#eee;border:1px solid #444;border-radius:3px;font-size:14px;width:200px"></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;â–¾</li><li><ul class=menu__dropdown><li><a href=/topics/>Topics</a></li><li><a href=/posts/>All</a></li><li><a href=/series/>Series</a></li><li><a href=/tags/>Tags</a></li><li><a href=/archive/>Archive</a></li><li><a href=/search/>Search</a></li><li><a href=/about/>About</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/topics/>Topics</a></li><li><a href=/posts/>All</a></li><li><a href=/series/>Series</a></li><li><a href=/tags/>Tags</a></li><li><a href=/archive/>Archive</a></li><li><a href=/search/>Search</a></li><li><a href=/about/>About</a></li></ul></nav></header><script>(function(){const e=document.getElementById("header-search");if(!e)return;e.addEventListener("keydown",function(e){if(e.key==="Enter"){const e=this.value.trim();e&&(window.location.href="/search?q="+encodeURIComponent(e))}}),document.addEventListener("keydown",function(t){t.key==="/"&&!["INPUT","TEXTAREA"].includes(t.target.tagName)&&(t.preventDefault(),e.focus()),t.key==="Escape"&&t.target===e&&e.blur()})})()</script><style>.header__inner{display:flex;align-items:center;gap:20px}.header__search{flex:none}#header-search::placeholder{color:#666;font-style:italic}#header-search:focus{outline:none;border-color:#888}@media(max-width:684px){.header__search{display:none}}</style><div class=content><article class=post><h1 class=post-title><a href=https://gazsecops.github.io/posts/workload-identity-beyond-api-keys/>Workload Identity: Giving Your Services an Identity Without the Secret Sprawl</a></h1><div class=post-meta><time class=post-date>2026-02-08</time><span class=post-author>Gareth</span><span class=post-reading-time>12 min read (2457 words)</span></div><span class=post-tags>#<a href=https://gazsecops.github.io/tags/security/>security</a>&nbsp;
#<a href=https://gazsecops.github.io/tags/identity/>identity</a>&nbsp;
#<a href=https://gazsecops.github.io/tags/cloud/>cloud</a>&nbsp;
#<a href=https://gazsecops.github.io/tags/kubernetes/>kubernetes</a>&nbsp;
#<a href=https://gazsecops.github.io/tags/spiffe/>spiffe</a>&nbsp;
#<a href=https://gazsecops.github.io/tags/operations/>operations</a>&nbsp;</span><div class=table-of-contents><h2>Table of Contents</h2><nav id=TableOfContents><ul><li><a href=#the-problem-services-need-identities-too>The Problem: Services Need Identities Too</a></li><li><a href=#what-workload-identity-actually-is>What Workload Identity Actually Is</a></li><li><a href=#cloud-native-workload-identity>Cloud-Native Workload Identity</a><ul><li><a href=#aws-iam-roles-for-service-accounts-irsa>AWS: IAM Roles for Service Accounts (IRSA)</a></li><li><a href=#azure-managed-identities>Azure: Managed Identities</a></li><li><a href=#gcp-workload-identity>GCP: Workload Identity</a></li></ul></li><li><a href=#self-hosted-and-on-premises-options>Self-Hosted and On-Premises Options</a><ul><li><a href=#option-1-hashicorp-vault-with-approle-or-kubernetes-auth>Option 1: HashiCorp Vault with AppRole or Kubernetes Auth</a></li><li><a href=#option-2-spiffe-and-spire>Option 2: SPIFFE and SPIRE</a></li><li><a href=#option-3-step-ca-with-acme-or-oidc-provisioners>Option 3: step-ca with ACME or OIDC Provisioners</a></li><li><a href=#option-4-keycloak-or-dex-for-oidc-based-identity>Option 4: Keycloak or Dex for OIDC-Based Identity</a></li><li><a href=#comparison-which-self-hosted-option>Comparison: Which Self-Hosted Option?</a></li></ul></li><li><a href=#simple-mtls-for-service-to-service>Simple mTLS for Service-to-Service</a></li><li><a href=#migration-path>Migration Path</a><ul><li><a href=#phase-1-inventory-existing-secrets>Phase 1: Inventory existing secrets</a></li><li><a href=#phase-2-move-secrets-to-managed-stores>Phase 2: Move secrets to managed stores</a></li><li><a href=#phase-3-identify-workloads-ready-for-workload-identity>Phase 3: Identify workloads ready for workload identity</a></li><li><a href=#phase-4-implement-per-platform>Phase 4: Implement per-platform</a></li><li><a href=#phase-5-deprecate-static-credentials>Phase 5: Deprecate static credentials</a></li></ul></li><li><a href=#monitoring-workload-identity>Monitoring Workload Identity</a><ul><li><a href=#key-metrics>Key metrics</a></li><li><a href=#alert-rules>Alert rules</a></li><li><a href=#quick-health-check>Quick health check</a></li></ul></li><li><a href=#common-mistakes>Common Mistakes</a><ul><li><a href=#mistake-1-mixing-workload-identity-with-static-credentials>Mistake 1: Mixing workload identity with static credentials</a></li><li><a href=#mistake-2-overly-permissive-roles>Mistake 2: Overly permissive roles</a></li><li><a href=#mistake-3-ignoring-on-prem-workloads>Mistake 3: Ignoring on-prem workloads</a></li><li><a href=#mistake-4-not-planning-for-workload-identity-outage>Mistake 4: Not planning for workload identity outage</a></li><li><a href=#mistake-5-forgetting-about-external-services>Mistake 5: Forgetting about external services</a></li></ul></li><li><a href=#the-boring-truth>The Boring Truth</a></li></ul></nav></div><div class=post-content><div><div class=dialogue><p><span class="speaker speaker-engineer">Engineer:</span> The database connection is failing.</p><p><span class="speaker speaker-sysadmin">Sysadmin:</span> Check the credentials in the config.</p><p><span class="speaker speaker-engineer">Engineer:</span> Which config? There are twelve.</p><p><span class="speaker speaker-sysadmin">Sysadmin:</span> The one with the password that expires every 90 days.</p><p><span class="speaker speaker-engineer">Engineer:</span> That expired yesterday. Nobody told me.</p><p><span class="speaker speaker-sysadmin">Sysadmin:</span> Did you check the rotation runbook?</p><p><span class="speaker speaker-engineer">Engineer:</span> The runbook is in a wiki that requires the database to log in.</p></div><p>Service accounts. API keys. Connection strings. Database passwords scattered across config files, environment variables, Kubernetes secrets, and that one spreadsheet someone maintains &ldquo;just in case&rdquo;. This is how most organisations handle non-human identity. It&rsquo;s also how most organisations get compromised.</p><aside class=pullquote>Every hardcoded credential is a future incident waiting to happen. The question isn't whether it leaks - it's whether you notice when it does.</aside><p>Workload identity is about giving your services proper identities without the secret sprawl. Not another password to rotate. Not another API key to revoke when it appears in a GitHub commit. An identity that your infrastructure manages, rotates, and revokes automatically.</p><p>This post covers what workload identity actually means, how to implement it on major clouds and on-prem, and the practical patterns that make it survivable.</p><h2 id=the-problem-services-need-identities-too>The Problem: Services Need Identities Too<a href=#the-problem-services-need-identities-too class=hanchor arialabel=Anchor>#</a></h2><p>Users have identities. They log in with SSO, use MFA, get provisioned and deprovisioned through HR systems. Messy, but understood.</p><p>Services also need identities. Your backend needs to talk to the database. Your batch job needs to write to storage. Your microservice needs to call another microservice. Currently, most of this is done with:</p><p><strong>API keys:</strong> Static strings that grant access until revoked. Found in logs, committed to repos, embedded in mobile apps. No expiry. No context. Just a password with a fancy name.</p><p><strong>Connection strings:</strong> Database URLs with embedded credentials. Rotated rarely because everything breaks when you change them. Stored in plain text config files because the application doesn&rsquo;t support secret injection.</p><p><strong>Service account passwords:</strong> Domain accounts or cloud IAM users with long-lived credentials. Shared across teams. Password set once and forgotten until audit time.</p><p><strong>Certificates:</strong> Better than passwords, but still need distribution, rotation, and revocation infrastructure. Most teams just set them to expire in five years and hope.</p><p>The common theme: secrets that exist in files, environment variables, and config management systems. Every place a secret lives is a place it can leak.</p><h2 id=what-workload-identity-actually-is>What Workload Identity Actually Is<a href=#what-workload-identity-actually-is class=hanchor arialabel=Anchor>#</a></h2><p>Workload identity means: a service gets an identity from the infrastructure, not from a secret you manage.</p><p>The flow:</p><ol><li>Service starts</li><li>Infrastructure proves the service is what it claims to be (attestation)</li><li>Infrastructure issues a short-lived credential (token, certificate)</li><li>Service uses credential to access resources</li><li>Credential expires, process repeats</li></ol><p>No passwords in config files. No API keys in environment variables. The infrastructure handles identity lifecycle.</p><p><strong>Key properties:</strong></p><ul><li><strong>Attestation:</strong> Something proves the workload is legitimate (cloud metadata service, Kubernetes service account, TPM, SPIFFE)</li><li><strong>Short-lived:</strong> Credentials last minutes or hours, not years</li><li><strong>Automatic rotation:</strong> Infrastructure renews credentials before expiry</li><li><strong>Revocable:</strong> Compromised workload loses identity immediately</li><li><strong>Auditable:</strong> Every token issuance is logged</li></ul><h2 id=cloud-native-workload-identity>Cloud-Native Workload Identity<a href=#cloud-native-workload-identity class=hanchor arialabel=Anchor>#</a></h2><p>Each major cloud has its own workload identity system. Use it. It&rsquo;s easier than building your own.</p><h3 id=aws-iam-roles-for-service-accounts-irsa>AWS: IAM Roles for Service Accounts (IRSA)<a href=#aws-iam-roles-for-service-accounts-irsa class=hanchor arialabel=Anchor>#</a></h3><p>Your EKS pods get AWS credentials automatically via Kubernetes service accounts.</p><p><strong>Setup (one-time):</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>eksctl utils associate-iam-oidc-provider <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  --cluster my-cluster <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  --approve
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>eksctl create iamserviceaccount <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  --name my-service <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  --namespace default <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  --cluster my-cluster <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  --role-name my-service-role <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  --attach-policy-arn arn:aws:iam::aws:policy/AmazonS3ReadOnlyAccess <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  --approve
</span></span></code></pre></div><p><strong>Pod usage:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>ServiceAccount</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-service</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>annotations</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>eks.amazonaws.com/role-arn</span>: <span style=color:#ae81ff>arn:aws:iam::123456789012:role/my-service-role</span>
</span></span><span style=display:flex><span>---
</span></span><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>apps/v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Deployment</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-service</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>template</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>serviceAccountName</span>: <span style=color:#ae81ff>my-service</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>        - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>app</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>image</span>: <span style=color:#ae81ff>my-image</span>
</span></span></code></pre></div><p>AWS SDKs automatically pick up credentials from the injected <code>AWS_ROLE_ARN</code> and token file. No code changes.</p><p><strong>On EC2 (non-Kubernetes):</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>instance_id<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>ec2-metadata -i | cut -d <span style=color:#e6db74>&#34; &#34;</span> -f 2<span style=color:#66d9ef>)</span>
</span></span><span style=display:flex><span>aws iam attach-role-policy <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  --role-name <span style=color:#e6db74>&#34;ec2-</span><span style=color:#e6db74>${</span>instance_id<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  --policy-arn arn:aws:iam::aws:policy/AmazonS3ReadOnlyAccess
</span></span></code></pre></div><p>Instance metadata service (IMDSv2) provides credentials. But IMDSv1 is vulnerable to SSRF - always enforce v2:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>aws ec2 modify-instance-metadata-options <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  --instance-id i-1234567890abcdef0 <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  --http-tokens required <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  --http-endpoint enabled
</span></span></code></pre></div><h3 id=azure-managed-identities>Azure: Managed Identities<a href=#azure-managed-identities class=hanchor arialabel=Anchor>#</a></h3><p>Azure handles workload identity via Managed Identities - either system-assigned (tied to resource lifecycle) or user-assigned (shared across resources).</p><p><strong>System-assigned (on VM):</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>az vm identity assign <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  --resource-group my-rg <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  --name my-vm <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  --role Reader <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  --scope /subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/my-rg
</span></span></code></pre></div><p><strong>User-assigned (on AKS pod):</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>az identity create <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  --resource-group my-rg <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  --name my-pod-identity
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>az aks pod-identity add <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  --resource-group my-rg <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  --cluster-name my-cluster <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  --namespace default <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  --service-account my-service <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  --identity-resource-id /subscriptions/.../resourcegroups/my-rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/my-pod-identity
</span></span></code></pre></div><p>Azure SDKs automatically use the managed identity. No connection strings:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> azure.identity <span style=color:#f92672>import</span> DefaultAzureCredential
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> azure.storage.blob <span style=color:#f92672>import</span> BlobServiceClient
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>credential <span style=color:#f92672>=</span> DefaultAzureCredential()
</span></span><span style=display:flex><span>client <span style=color:#f92672>=</span> BlobServiceClient(
</span></span><span style=display:flex><span>    account_url<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;https://mystorage.blob.core.windows.net&#34;</span>,
</span></span><span style=display:flex><span>    credential<span style=color:#f92672>=</span>credential
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><h3 id=gcp-workload-identity>GCP: Workload Identity<a href=#gcp-workload-identity class=hanchor arialabel=Anchor>#</a></h3><p>GCP ties Kubernetes service accounts to GCP service accounts.</p><p><strong>Setup:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>gcloud iam service-accounts create my-service-sa
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>gcloud projects add-iam-policy-binding my-project <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  --member <span style=color:#e6db74>&#34;serviceAccount:my-service-sa@my-project.iam.gserviceaccount.com&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  --role <span style=color:#e6db74>&#34;roles/storage.objectViewer&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>gcloud iam service-accounts add-iam-policy-binding <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  my-service-sa@my-project.iam.gserviceaccount.com <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  --member <span style=color:#e6db74>&#34;serviceAccount:my-project.svc.id.goog[default/my-service]&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  --role <span style=color:#e6db74>&#34;roles/iam.workloadIdentityUser&#34;</span>
</span></span></code></pre></div><p><strong>Pod annotation:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>ServiceAccount</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-service</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>annotations</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>iam.gke.io/gcp-service-account</span>: <span style=color:#ae81ff>my-service-sa@my-project.iam.gserviceaccount.com</span>
</span></span></code></pre></div><p>GCP libraries pick up credentials automatically from the metadata server.</p><h2 id=self-hosted-and-on-premises-options>Self-Hosted and On-Premises Options<a href=#self-hosted-and-on-premises-options class=hanchor arialabel=Anchor>#</a></h2><p>Not on a cloud? Running your own infrastructure? Multi-cloud and need something portable? You have options.</p><h3 id=option-1-hashicorp-vault-with-approle-or-kubernetes-auth>Option 1: HashiCorp Vault with AppRole or Kubernetes Auth<a href=#option-1-hashicorp-vault-with-approle-or-kubernetes-auth class=hanchor arialabel=Anchor>#</a></h3><p>Vault is primarily a secrets engine, but it also provides workload identity via auth methods. Services authenticate to Vault using platform-specific attestation, then retrieve short-lived credentials.</p><p><strong>Kubernetes auth (for pods):</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>vault auth enable kubernetes
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>vault write auth/kubernetes/config <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  kubernetes_host<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;https://kubernetes.default.svc:443&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  kubernetes_ca_cert<span style=color:#f92672>=</span>@/var/run/secrets/kubernetes.io/serviceaccount/ca.crt <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  token_reviewer_jwt<span style=color:#f92672>=</span>@/var/run/secrets/kubernetes.io/serviceaccount/token
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>vault write auth/kubernetes/role/my-service <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  bound_service_account_names<span style=color:#f92672>=</span>my-service <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  bound_service_account_namespaces<span style=color:#f92672>=</span>default <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  policies<span style=color:#f92672>=</span>my-service-policy <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  ttl<span style=color:#f92672>=</span>1h
</span></span></code></pre></div><p>Pod authenticates:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>vault write auth/kubernetes/login <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  role<span style=color:#f92672>=</span>my-service <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  jwt<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>cat /var/run/secrets/kubernetes.io/serviceaccount/token<span style=color:#66d9ef>)</span>
</span></span></code></pre></div><p><strong>AppRole auth (for VMs/systemd services):</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>vault auth enable approle
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>vault write auth/approle/role/my-service <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  secret_id_ttl<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  token_ttl<span style=color:#f92672>=</span>1h <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  token_max_ttl<span style=color:#f92672>=</span>4h <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  policies<span style=color:#f92672>=</span>my-service-policy
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>vault read auth/approle/role/my-service/role-id
</span></span><span style=display:flex><span>vault write -f auth/approle/role/my-service/secret-id
</span></span></code></pre></div><p>Service authenticates:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>vault write auth/approle/login <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  role_id<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;abc123&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  secret_id<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;xyz789&#34;</span>
</span></span></code></pre></div><p>The role-id is semi-public (can be in config). The secret-id is delivered via secure channel (cloud-init, orchestration tool, one-time fetch).</p><p><strong>What you get:</strong></p><ul><li>Short-lived Vault tokens (hours, not years)</li><li>Automatic token renewal</li><li>Audit log of every authentication</li><li>Fine-grained policies (this service can only read these secrets)</li></ul><p><strong>Limitation:</strong> Vault is a single point of failure. High availability setup is essential for production.</p><h3 id=option-2-spiffe-and-spire>Option 2: SPIFFE and SPIRE<a href=#option-2-spiffe-and-spire class=hanchor arialabel=Anchor>#</a></h3><p>SPIFFE (Secure Production Identity Framework for Everyone) defines a standard for workload identity. SPIRE is the reference implementation. This is the most cloud-agnostic option.</p><p><strong>Architecture:</strong></p><ul><li>SPIRE Server: Issues identity documents (SVIDs - SPIFFE Verifiable Identity Documents)</li><li>SPIRE Agent: Runs on each node, attests workloads, provides SVIDs</li><li>Workload: Gets SVID from agent via Unix socket or Workload API</li></ul><p><strong>Server setup (Linux systemd):</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>curl -sSL https://github.com/spiffe/spire/releases/download/v1.9.0/spire-1.9.0-linux-x86_64-glibc.tar.gz | tar xz
</span></span><span style=display:flex><span>cd spire-1.9.0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cat &gt; conf/server/server.conf <span style=color:#e6db74>&lt;&lt; &#39;EOF&#39;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>server {
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    bind_address = &#34;0.0.0.0&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    bind_port = &#34;8081&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    trust_domain = &#34;example.org&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    data_dir = &#34;/var/lib/spire/data&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    log_level = &#34;INFO&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>}
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>plugins {
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    DataStore &#34;sql&#34; {
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        plugin_data {
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            database_type = &#34;sqlite3&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            connection_string = &#34;/var/lib/spire/datastore.sqlite3&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        }
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    }
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    NodeAttestor &#34;x509pop&#34; {
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        plugin_data {}
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    }
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    KeyManager &#34;memory&#34; {
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        plugin_data {}
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    }
</span></span></span><span style=display:flex><span><span style=color:#e6db74>}
</span></span></span><span style=display:flex><span><span style=color:#e6db74>EOF</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>./bin/spire-server run -config conf/server/server.conf &amp;
</span></span></code></pre></div><p><strong>Agent setup:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>cat &gt; conf/agent/agent.conf <span style=color:#e6db74>&lt;&lt; &#39;EOF&#39;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>agent {
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    data_dir = &#34;/var/lib/spire/agent/data&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    log_level = &#34;INFO&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    server_address = &#34;spire-server&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    server_port = &#34;8081&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    trust_bundle_path = &#34;/var/lib/spire/bundle.crt&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    trust_domain = &#34;example.org&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>}
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>plugins {
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    NodeAttestor &#34;x509pop&#34; {
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        plugin_data {}
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    }
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    WorkloadAttestor &#34;unix&#34; {
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        plugin_data {}
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    }
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    KeyManager &#34;memory&#34; {
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        plugin_data {}
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    }
</span></span></span><span style=display:flex><span><span style=color:#e6db74>}
</span></span></span><span style=display:flex><span><span style=color:#e6db74>EOF</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>./bin/spire-agent run -config conf/agent/agent.conf &amp;
</span></span></code></pre></div><p><strong>Register a workload (by Unix user):</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>./bin/spire-server entry create <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  -spiffeID spiffe://example.org/my-service <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  -parentID spiffe://example.org/spire/agent/x509pop/<span style=color:#66d9ef>$(</span>./bin/spire-server agent list -raw | jq -r <span style=color:#e6db74>&#39;.[] | select(.spiffe_id | contains(&#34;agent&#34;)) | .spiffe_id | split(&#34;/&#34;)[-1]&#39;</span><span style=color:#66d9ef>)</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  -selector unix:user:myapp <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  -ttl <span style=color:#ae81ff>3600</span>
</span></span></code></pre></div><p><strong>Workload retrieves SVID:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>./bin/spire-agent api fetch -socketPath /tmp/agent.sock
</span></span></code></pre></div><p><strong>Integration options:</strong></p><ul><li><strong>Service mesh:</strong> Istio, Linkerd, Consul Connect have native SPIFFE integration</li><li><strong>Envoy:</strong> SPIRE can push SVIDs to Envoy sidecars</li><li><strong>Application:</strong> Use SPIFFE Workload API client libraries</li></ul><p><strong>Attestation methods:</strong></p><ul><li>Kubernetes: Service account token, pod UID</li><li>Unix: User ID, group ID, process ID</li><li>AWS: Instance identity document, IAM role</li><li>Azure: Managed identity</li><li>GCP: Instance identity token</li></ul><h3 id=option-3-step-ca-with-acme-or-oidc-provisioners>Option 3: step-ca with ACME or OIDC Provisioners<a href=#option-3-step-ca-with-acme-or-oidc-provisioners class=hanchor arialabel=Anchor>#</a></h3><p>If you already have step-ca running (from the PKI post), extend it for workload identity.</p><p><strong>ACME provisioner (for automated cert issuance):</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>step ca provisioner add acme --type ACME
</span></span></code></pre></div><p>Services use ACME client (certbot, acme.sh, Caddy) to get certificates:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>certbot certonly --standalone <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  --server https://ca.prod.internal:443/acme/acme/directory <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  --preferred-chain <span style=color:#e6db74>&#34;Root CA&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  -d my-service.prod.internal
</span></span></code></pre></div><p><strong>OIDC provisioner (for services with OIDC identity):</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>step ca provisioner add oidc --type OIDC <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  --client-id step-ca <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  --client-secret $SECRET <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  --configuration-endpoint https://keycloak.internal/realms/prod/.well-known/openid-configuration
</span></span></code></pre></div><p>Services authenticate with OIDC token, get certificate:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>step ca certificate my-service.prod.internal <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  /etc/tls/service.crt /etc/tls/service.key <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  --ca-url https://ca.prod.internal:443 <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  --root /etc/step-ca/certs/root_ca.crt <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  --provisioner oidc --provisioner-password-file /etc/step-ca/oidc.token
</span></span></code></pre></div><h3 id=option-4-keycloak-or-dex-for-oidc-based-identity>Option 4: Keycloak or Dex for OIDC-Based Identity<a href=#option-4-keycloak-or-dex-for-oidc-based-identity class=hanchor arialabel=Anchor>#</a></h3><p>If you already run an OIDC provider (Keycloak, Dex), use it for workload identity.</p><p><strong>Pattern:</strong></p><ol><li>Create a &ldquo;confidential client&rdquo; for each service in Keycloak</li><li>Service authenticates with client credentials grant</li><li>Service gets JWT access token</li><li>Token used to authenticate to other services</li></ol><p><strong>Keycloak client setup:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>kcadm.sh create clients <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  -r production <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  -s clientId<span style=color:#f92672>=</span>my-service <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  -s secret<span style=color:#f92672>=</span>$SERVICE_SECRET <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  -s serviceAccountsEnabled<span style=color:#f92672>=</span>true <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  -s directAccessGrantsEnabled<span style=color:#f92672>=</span>true <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  -s authorizationServicesEnabled<span style=color:#f92672>=</span>true
</span></span></code></pre></div><p><strong>Service authentication:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>curl -s -X POST <span style=color:#e6db74>&#34;https://keycloak.internal/realms/production/protocol/openid-connect/token&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  -d <span style=color:#e6db74>&#34;grant_type=client_credentials&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  -d <span style=color:#e6db74>&#34;client_id=my-service&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  -d <span style=color:#e6db74>&#34;client_secret=</span>$SERVICE_SECRET<span style=color:#e6db74>&#34;</span>
</span></span></code></pre></div><p><strong>Limitation:</strong> Still need to manage client secrets. Consider combining with SPIRE for secretless authentication (SPIRE attests workload, workload gets Keycloak token).</p><h3 id=comparison-which-self-hosted-option>Comparison: Which Self-Hosted Option?<a href=#comparison-which-self-hosted-option class=hanchor arialabel=Anchor>#</a></h3><table><thead><tr><th>Option</th><th>Best For</th><th>Complexity</th><th>Attestation</th></tr></thead><tbody><tr><td>Vault</td><td>Already using Vault for secrets</td><td>Medium</td><td>AppRole, Kubernetes, OIDC, AWS, Azure, GCP</td></tr><tr><td>SPIRE</td><td>Portable, cloud-agnostic identity</td><td>High</td><td>Unix, Kubernetes, cloud platforms</td></tr><tr><td>step-ca</td><td>PKI-focused, certificate identity</td><td>Medium</td><td>ACME, OIDC, JWK</td></tr><tr><td>Keycloak/Dex</td><td>Already have OIDC infrastructure</td><td>Medium</td><td>Client credentials</td></tr></tbody></table><p><strong>Recommendation:</strong></p><ul><li>Already using Vault? Use Vault auth methods.</li><li>Need maximum portability? SPIRE.</li><li>Already have internal CA? step-ca.</li><li>Already have OIDC? Keycloak client credentials.</li></ul><p>Don&rsquo;t build your own. These problems are harder than they look.</p><h2 id=simple-mtls-for-service-to-service>Simple mTLS for Service-to-Service<a href=#simple-mtls-for-service-to-service class=hanchor arialabel=Anchor>#</a></h2><p>If SPIRE feels like overkill, mutual TLS with short-lived certificates is a reasonable middle ground.</p><p><strong>Pattern:</strong></p><ol><li>Each service has a certificate issued by internal CA</li><li>Certificates last 24-72 hours</li><li>Renewal happens automatically before expiry</li><li>Services verify each other&rsquo;s certificates</li></ol><p><strong>With step-ca (covered in previous post):</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>step ca certificate my-service.prod.internal <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  /etc/tls/service.crt /etc/tls/service.key <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  --ca-url https://ca.prod.internal:443 <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  --root /etc/step-ca/certs/root_ca.crt <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  --provisioner jwt --provisioner-password-file /etc/step-ca/provisioner.password
</span></span></code></pre></div><p>Systemd timer for renewal:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-ini data-lang=ini><span style=display:flex><span><span style=color:#66d9ef>[Unit]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Description</span><span style=color:#f92672>=</span><span style=color:#e6db74>Renew service certificate</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>[Timer]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>OnCalendar</span><span style=color:#f92672>=</span><span style=color:#e6db74>*:0/4</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>[Install]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>WantedBy</span><span style=color:#f92672>=</span><span style=color:#e6db74>timers.target</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-ini data-lang=ini><span style=display:flex><span><span style=color:#66d9ef>[Service]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Type</span><span style=color:#f92672>=</span><span style=color:#e6db74>oneshot</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ExecStart</span><span style=color:#f92672>=</span><span style=color:#e6db74>/usr/bin/step ca renew /etc/tls/service.crt /etc/tls/service.key \
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  --ca-url https://ca.prod.internal:443 \
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  --root /etc/step-ca/certs/root_ca.crt \
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  --force</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ExecStartPost</span><span style=color:#f92672>=</span><span style=color:#e6db74>/usr/bin/systemctl reload my-service</span>
</span></span></code></pre></div><h2 id=migration-path>Migration Path<a href=#migration-path class=hanchor arialabel=Anchor>#</a></h2><p>You probably have services using API keys right now. How do you migrate?</p><h3 id=phase-1-inventory-existing-secrets>Phase 1: Inventory existing secrets<a href=#phase-1-inventory-existing-secrets class=hanchor arialabel=Anchor>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl get secrets --all-namespaces -o json | jq -r <span style=color:#e6db74>&#39;.items[] | .metadata.namespace + &#34;/&#34; + .metadata.name&#39;</span>
</span></span></code></pre></div><p>Find hardcoded credentials:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>gitleaks detect --source . --report-path findings.json
</span></span><span style=display:flex><span>trufflehog filesystem . --json &gt; findings.json
</span></span></code></pre></div><h3 id=phase-2-move-secrets-to-managed-stores>Phase 2: Move secrets to managed stores<a href=#phase-2-move-secrets-to-managed-stores class=hanchor arialabel=Anchor>#</a></h3><p>Not workload identity yet, but at least centralised:</p><ul><li>Kubernetes: External Secrets Operator syncing from Vault/cloud secret stores</li><li>VMs: HashiCorp Vault agent or cloud secret manager</li><li>Containers: Mount secrets at runtime, don&rsquo;t bake into images</li></ul><h3 id=phase-3-identify-workloads-ready-for-workload-identity>Phase 3: Identify workloads ready for workload identity<a href=#phase-3-identify-workloads-ready-for-workload-identity class=hanchor arialabel=Anchor>#</a></h3><p>Start with:</p><ul><li>New services (easier to build right from start)</li><li>Services already running on supported platforms (EKS, AKS, GKE)</li><li>High-value services (database access, storage access)</li></ul><h3 id=phase-4-implement-per-platform>Phase 4: Implement per-platform<a href=#phase-4-implement-per-platform class=hanchor arialabel=Anchor>#</a></h3><ul><li>AWS: IRSA for EKS workloads</li><li>Azure: Managed Identity for AKS and VMs</li><li>GCP: Workload Identity for GKE</li><li>On-prem: SPIRE or step-ca for mTLS</li></ul><h3 id=phase-5-deprecate-static-credentials>Phase 5: Deprecate static credentials<a href=#phase-5-deprecate-static-credentials class=hanchor arialabel=Anchor>#</a></h3><p>Once workload identity works:</p><ol><li>Remove static credentials from secret stores</li><li>Add validation that services use workload identity (not static creds)</li><li>Alert when static credentials are created</li></ol><h2 id=monitoring-workload-identity>Monitoring Workload Identity<a href=#monitoring-workload-identity class=hanchor arialabel=Anchor>#</a></h2><p>When workload identity breaks, everything breaks. Monitor it.</p><h3 id=key-metrics>Key metrics<a href=#key-metrics class=hanchor arialabel=Anchor>#</a></h3><p><strong>Token/certificate issuance rate:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-promql data-lang=promql><span style=display:flex><span><span style=color:#66d9ef>rate</span><span style=color:#f92672>(</span>workload_identity_tokens_issued_total[<span style=color:#e6db74>5m</span>]<span style=color:#f92672>)</span>
</span></span></code></pre></div><p><strong>Token fetch failures:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-promql data-lang=promql><span style=display:flex><span><span style=color:#66d9ef>rate</span><span style=color:#f92672>(</span>workload_identity_token_fetch_errors_total[<span style=color:#e6db74>5m</span>]<span style=color:#f92672>)</span> <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>
</span></span></code></pre></div><p><strong>Token expiry (alert before expiry):</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-promql data-lang=promql><span style=display:flex><span>workload_identity_token_expiry_timestamp <span style=color:#f92672>-</span> <span style=color:#66d9ef>time</span><span style=color:#f92672>()</span> <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>300</span>
</span></span></code></pre></div><p><strong>AWS IRSA specific:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-promql data-lang=promql><span style=display:flex><span>aws_assume_role_errors_total{role_arn<span style=color:#f92672>=~</span>&#34;<span style=color:#e6db74>.*my-service-role.*</span>&#34;}
</span></span></code></pre></div><p><strong>Azure Managed Identity:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-promql data-lang=promql><span style=display:flex><span>azure_managed_identity_token_requests_total{result<span style=color:#f92672>=</span>&#34;<span style=color:#e6db74>failed</span>&#34;}
</span></span></code></pre></div><p><strong>Vault:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-promql data-lang=promql><span style=display:flex><span>vault_token_creation_count
</span></span><span style=display:flex><span>vault_auth_approle_login_total{result<span style=color:#f92672>=</span>&#34;<span style=color:#e6db74>error</span>&#34;}
</span></span><span style=display:flex><span>vault_auth_kubernetes_login_total{result<span style=color:#f92672>=</span>&#34;<span style=color:#e6db74>error</span>&#34;}
</span></span></code></pre></div><p><strong>SPIRE:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-promql data-lang=promql><span style=display:flex><span>spire_server_svids_issued_total
</span></span><span style=display:flex><span>spire_agent_workload_api_fetch_total{result<span style=color:#f92672>=</span>&#34;<span style=color:#e6db74>error</span>&#34;}
</span></span></code></pre></div><p><strong>step-ca:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-promql data-lang=promql><span style=display:flex><span>step_ca_certificates_issued_total
</span></span><span style=display:flex><span>step_ca_renewal_failures_total
</span></span></code></pre></div><h3 id=alert-rules>Alert rules<a href=#alert-rules class=hanchor arialabel=Anchor>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>groups</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>workload-identity</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>rules</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>alert</span>: <span style=color:#ae81ff>WorkloadIdentityTokenFetchFailing</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>expr</span>: <span style=color:#ae81ff>rate(workload_identity_token_fetch_errors_total[5m]) &gt; 0.1</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>for</span>: <span style=color:#ae81ff>2m</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>labels</span>:
</span></span><span style=display:flex><span>          <span style=color:#f92672>severity</span>: <span style=color:#ae81ff>critical</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>annotations</span>:
</span></span><span style=display:flex><span>          <span style=color:#f92672>summary</span>: <span style=color:#e6db74>&#34;Workload identity token fetch failing for {{ $labels.service }}&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      - <span style=color:#f92672>alert</span>: <span style=color:#ae81ff>WorkloadIdentityTokenExpiringSoon</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>expr</span>: <span style=color:#ae81ff>workload_identity_token_expiry_timestamp - time() &lt; 300</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>for</span>: <span style=color:#ae81ff>1m</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>labels</span>:
</span></span><span style=display:flex><span>          <span style=color:#f92672>severity</span>: <span style=color:#ae81ff>critical</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>annotations</span>:
</span></span><span style=display:flex><span>          <span style=color:#f92672>summary</span>: <span style=color:#e6db74>&#34;Workload identity token for {{ $labels.service }} expires in &lt; 5 minutes&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      - <span style=color:#f92672>alert</span>: <span style=color:#ae81ff>WorkloadIdentityIssuanceStopped</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>expr</span>: |<span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>          rate(workload_identity_tokens_issued_total[10m]) == 0
</span></span></span><span style=display:flex><span><span style=color:#e6db74>          and on() (count(up{job=&#34;workload-identity-server&#34;}) &gt; 0)</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>for</span>: <span style=color:#ae81ff>10m</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>labels</span>:
</span></span><span style=display:flex><span>          <span style=color:#f92672>severity</span>: <span style=color:#ae81ff>warning</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>annotations</span>:
</span></span><span style=display:flex><span>          <span style=color:#f92672>summary</span>: <span style=color:#e6db74>&#34;No workload identity tokens issued in 10 minutes - is attestation working?&#34;</span>
</span></span></code></pre></div><h3 id=quick-health-check>Quick health check<a href=#quick-health-check class=hanchor arialabel=Anchor>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># AWS IRSA</span>
</span></span><span style=display:flex><span>curl -s http://169.254.169.254/latest/meta-data/iam/security-credentials/
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Azure Managed Identity</span>
</span></span><span style=display:flex><span>curl -s <span style=color:#e6db74>&#39;http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&amp;resource=https://storage.azure.com/&#39;</span> -H Metadata:true
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># GCP Workload Identity</span>
</span></span><span style=display:flex><span>curl -s -H <span style=color:#e6db74>&#39;Metadata-Flavor: Google&#39;</span> <span style=color:#e6db74>&#39;http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># SPIRE</span>
</span></span><span style=display:flex><span>./bin/spire-agent api fetch -socketPath /tmp/agent.sock
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Vault (check auth method)</span>
</span></span><span style=display:flex><span>vault status
</span></span><span style=display:flex><span>vault audit list
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># step-ca</span>
</span></span><span style=display:flex><span>curl -s http://ca.prod.internal:443/health
</span></span><span style=display:flex><span>step ca health --ca-url https://ca.prod.internal:443
</span></span></code></pre></div><h2 id=common-mistakes>Common Mistakes<a href=#common-mistakes class=hanchor arialabel=Anchor>#</a></h2><h3 id=mistake-1-mixing-workload-identity-with-static-credentials>Mistake 1: Mixing workload identity with static credentials<a href=#mistake-1-mixing-workload-identity-with-static-credentials class=hanchor arialabel=Anchor>#</a></h3><p>Workload identity for some things, API keys for others. The API keys become the path of least resistance and never get removed.</p><p><strong>Fix:</strong> New services must use workload identity. No exceptions. Old services get migrated on a schedule.</p><h3 id=mistake-2-overly-permissive-roles>Mistake 2: Overly permissive roles<a href=#mistake-2-overly-permissive-roles class=hanchor arialabel=Anchor>#</a></h3><p>Workload identity proves who the service is. It doesn&rsquo;t limit what the service can do if you grant it <code>AdministratorAccess</code>.</p><p><strong>Fix:</strong> Least privilege. Service role can only access specific S3 bucket, specific database, specific API.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>aws iam put-role-policy <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  --role-name my-service-role <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  --policy-name S3Access <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  --policy-document <span style=color:#e6db74>&#39;{
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;Version&#34;: &#34;2012-10-17&#34;,
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;Statement&#34;: [{
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      &#34;Effect&#34;: &#34;Allow&#34;,
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      &#34;Action&#34;: [&#34;s3:GetObject&#34;, &#34;s3:PutObject&#34;],
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      &#34;Resource&#34;: &#34;arn:aws:s3:::my-bucket/*&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    }]
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  }&#39;</span>
</span></span></code></pre></div><h3 id=mistake-3-ignoring-on-prem-workloads>Mistake 3: Ignoring on-prem workloads<a href=#mistake-3-ignoring-on-prem-workloads class=hanchor arialabel=Anchor>#</a></h3><p>Cloud workloads get workload identity. On-prem workloads get hardcoded credentials in config files. Attackers notice.</p><p><strong>Fix:</strong> SPIRE or step-ca for on-prem. Same identity model everywhere.</p><h3 id=mistake-4-not-planning-for-workload-identity-outage>Mistake 4: Not planning for workload identity outage<a href=#mistake-4-not-planning-for-workload-identity-outage class=hanchor arialabel=Anchor>#</a></h3><p>The identity service goes down. Now no service can authenticate. Everything cascades.</p><p><strong>Fix:</strong></p><ul><li>High availability for identity services (SPIRE server, step-ca, cloud provider)</li><li>Longer token lifetimes for critical services (24 hours, not 1 hour)</li><li>Break-glass procedure for emergency static credentials (sealed, audited)</li></ul><h3 id=mistake-5-forgetting-about-external-services>Mistake 5: Forgetting about external services<a href=#mistake-5-forgetting-about-external-services class=hanchor arialabel=Anchor>#</a></h3><p>Workload identity works great for internal services. But your service still needs an API key to call that third-party API.</p><p><strong>Fix:</strong></p><ul><li>External secrets stored in Vault or cloud secret manager</li><li>Accessed via workload identity (service uses identity to fetch external secret)</li><li>Still better than hardcoded everywhere</li></ul><h2 id=the-boring-truth>The Boring Truth<a href=#the-boring-truth class=hanchor arialabel=Anchor>#</a></h2><p>Workload identity isn&rsquo;t exciting. It&rsquo;s infrastructure plumbing. But it eliminates an entire class of credential-related incidents:</p><ul><li>No more hardcoded passwords in repos</li><li>No more credential rotation emergencies</li><li>No more shared service accounts</li><li>No more &ldquo;who has access to this API key?&rdquo;</li></ul><p>The migration takes time. Start with new services. Chip away at old ones. Eventually, you realise you haven&rsquo;t rotated a static credential in months because you don&rsquo;t have any left.</p><p>That&rsquo;s the goal. Not fancy identity infrastructure - just fewer secrets to manage and fewer incidents to explain.</p><hr><p><em>If you want the PKI side of this, see the <a href=/posts/stepca-running-internal-pki/>step-ca post</a>. If you want to understand how identity flows through microservice chains, the <a href=/posts/oauth2-obo-flow-complete-guide/>OBO flow guide</a> covers preserving user context. If you just want to know what secrets you&rsquo;ve already leaked, run <code>gitleaks detect</code> and prepare for a long afternoon.</em></p></div></div><div class=related-posts style="margin-top:3rem;padding-top:2rem;border-top:1px solid #333"><h3>Related Posts</h3><ul style=list-style:none;padding:0><li style=margin-bottom:1rem><a href=https://gazsecops.github.io/posts/zero-trust-what-it-actually-means/>Zero Trust: What It Actually Means When You Have to Implement It</a>
<span style=color:#999;font-size:.9rem>- 5 Aug 2025</span><div style=font-size:.85rem;color:#666;margin-top:.25rem><span style=margin-right:.5rem>#security</span>
<span style=margin-right:.5rem>#zero-trust</span>
<span style=margin-right:.5rem>#networking</span>
<span style=margin-right:.5rem>#identity</span>
<span style=margin-right:.5rem>#cloud</span>
<span style=margin-right:.5rem>#operations</span></div></li><li style=margin-bottom:1rem><a href=https://gazsecops.github.io/posts/stepca-running-internal-pki/>Smallstep step-ca: Running Internal PKI Without Losing Your Mind</a>
<span style=color:#999;font-size:.9rem>- 28 Oct 2025</span><div style=font-size:.85rem;color:#666;margin-top:.25rem><span style=margin-right:.5rem>#security</span>
<span style=margin-right:.5rem>#pki</span>
<span style=margin-right:.5rem>#tls</span>
<span style=margin-right:.5rem>#certificates</span>
<span style=margin-right:.5rem>#linux</span>
<span style=margin-right:.5rem>#cloud</span>
<span style=margin-right:.5rem>#operations</span></div></li><li style=margin-bottom:1rem><a href=https://gazsecops.github.io/posts/incident-response-what-actually-works/>Incident Response: What Actually Works at 3am</a>
<span style=color:#999;font-size:.9rem>- 2 Jul 2025</span><div style=font-size:.85rem;color:#666;margin-top:.25rem><span style=margin-right:.5rem>#security</span>
<span style=margin-right:.5rem>#incident-response</span>
<span style=margin-right:.5rem>#operations</span>
<span style=margin-right:.5rem>#linux</span>
<span style=margin-right:.5rem>#cloud</span></div></li><li style=margin-bottom:1rem><a href=https://gazsecops.github.io/posts/dns-security-what-actually-breaks/>DNS Security: What Actually Breaks</a>
<span style=color:#999;font-size:.9rem>- 12 Jun 2025</span><div style=font-size:.85rem;color:#666;margin-top:.25rem><span style=margin-right:.5rem>#security</span>
<span style=margin-right:.5rem>#dns</span>
<span style=margin-right:.5rem>#linux</span>
<span style=margin-right:.5rem>#cloud</span>
<span style=margin-right:.5rem>#monitoring</span>
<span style=margin-right:.5rem>#operations</span>
<span style=margin-right:.5rem>#incident-response</span></div></li><li style=margin-bottom:1rem><a href=https://gazsecops.github.io/posts/security-as-code-beyond-scanning/>Beyond Scanning: What Security as Code Really Means</a>
<span style=color:#999;font-size:.9rem>- 22 Nov 2025</span><div style=font-size:.85rem;color:#666;margin-top:.25rem><span style=margin-right:.5rem>#security</span>
<span style=margin-right:.5rem>#devsecops</span>
<span style=margin-right:.5rem>#automation</span>
<span style=margin-right:.5rem>#culture</span>
<span style=margin-right:.5rem>#operations</span></div></li></ul></div><div class=pagination><div class=pagination__title><span class=pagination__title-h></span><hr></div><div class=pagination__buttons><a href=https://gazsecops.github.io/posts/threat-analysis-practical-guide/ class="button inline prev">&lt; [<span class=button__text>Threat Analysis: What Actually Works</span>]
</a>::
<a href=https://gazsecops.github.io/posts/azure-logic-apps-security-guide/ class="button inline next">[<span class=button__text>Azure Logic Apps Security: A Guide for Cyber Security Consultants</span>] ></a></div></div></article></div><footer class=footer><div class=footer__inner><div class=copyright><span>Â© 2026</span></div><div class=build-info><span class=build-commit>e733073</span><span class=build-date>2026-02-12 12:33 UTC</span></div></div></footer></div></body></html>