<!doctype html><html lang=en><head><title>OAuth 2.0 Security: What Actually Breaks :: Gareth's Engineering Blog</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content=" Engineer: We need OAuth for the new API.
Sysadmin: Have you implemented PKCE?
Engineer: What&rsquo;s PKCE?
Sysadmin: Proof Key for Code Exchange. Prevents authorisation code interception.
Engineer: Is that the state parameter thing?
Sysadmin: No, that&rsquo;s CSRF protection. Different problem.
Engineer: &mldr;we might need to start over.
This conversation happens constantly. OAuth 2.0 is everywhere, but most implementations get it wrong. Not spectacularly wrong. Just wrong enough to be exploitable.
&#34;OAuth 2.0 isn't hard because the spec is complex. It's hard because the spec gives you enough rope to hang yourself, and most people do exactly that.&#34; The OAuth 2.0 specification is a framework, not a protocol. It gives you options. Most of those options are wrong for your use case. The security comes from knowing which options to pick and which to avoid.
"><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://gazsecops.github.io/posts/oauth2-security-pitfalls/><link rel=stylesheet href=https://gazsecops.github.io/css/extended.min.c658c723e006469d82f697e19c5338967fad12c57650bdd915bacf9cfbe2cc38.css><link rel=stylesheet href=https://gazsecops.github.io/css/buttons.min.86f6b4c106b6c6eb690ae5203d36b442c1f66f718ff4e8164fa86cf6c61ad641.css><link rel=stylesheet href=https://gazsecops.github.io/css/code.min.d529ea4b2fb8d34328d7d31afc5466d5f7bc2f0bc9abdd98b69385335d7baee4.css><link rel=stylesheet href=https://gazsecops.github.io/css/fonts.min.5bb7ed13e1d00d8ff39ea84af26737007eb5051b157b86fc24487c94f3dc8bbe.css><link rel=stylesheet href=https://gazsecops.github.io/css/footer.min.eb8dfc2c6a7eafa36cd3ba92d63e69e849e2200e0002a228d137f236b09ecd75.css><link rel=stylesheet href=https://gazsecops.github.io/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css><link rel=stylesheet href=https://gazsecops.github.io/css/header.min.75c7eb0e2872d95ff48109c6647d0223a38db52e2561dd87966eb5fc7c6bdac6.css><link rel=stylesheet href=https://gazsecops.github.io/css/main.min.36833afd348409fc6c3d09d0897c5833d9d5bf1ff31f5e60ea3ee42ce2b1268c.css><link rel=stylesheet href=https://gazsecops.github.io/css/menu.min.3c17467ebeb3d38663dce68f71f519901124fa5cbb4519b2fb0667a21e9aca39.css><link rel=stylesheet href=https://gazsecops.github.io/css/pagination.min.bbb986dbce00a5ce5aca0504b7925fc1c581992a4bf57f163e5d69cc1db7d836.css><link rel=stylesheet href=https://gazsecops.github.io/css/post.min.e6dddd258e64c83e05cec0cd49c05216742d42fc8ecbfbe6b67083412b609bd3.css><link rel=stylesheet href=https://gazsecops.github.io/css/syntax.min.a0773cce9310cb6d8ed23e50f005448facf29a53001b57e038828daa466b25c0.css><link rel=stylesheet href=https://gazsecops.github.io/css/terminal.min.e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css><link rel=stylesheet href=https://gazsecops.github.io/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css><link rel="shortcut icon" href=https://gazsecops.github.io/favicon.png><link rel=apple-touch-icon href=https://gazsecops.github.io/apple-touch-icon.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="OAuth 2.0 Security: What Actually Breaks"><meta property="og:description" content=" Engineer: We need OAuth for the new API.
Sysadmin: Have you implemented PKCE?
Engineer: What&rsquo;s PKCE?
Sysadmin: Proof Key for Code Exchange. Prevents authorisation code interception.
Engineer: Is that the state parameter thing?
Sysadmin: No, that&rsquo;s CSRF protection. Different problem.
Engineer: &mldr;we might need to start over.
This conversation happens constantly. OAuth 2.0 is everywhere, but most implementations get it wrong. Not spectacularly wrong. Just wrong enough to be exploitable.
&#34;OAuth 2.0 isn't hard because the spec is complex. It's hard because the spec gives you enough rope to hang yourself, and most people do exactly that.&#34; The OAuth 2.0 specification is a framework, not a protocol. It gives you options. Most of those options are wrong for your use case. The security comes from knowing which options to pick and which to avoid.
"><meta property="og:url" content="https://gazsecops.github.io/posts/oauth2-security-pitfalls/"><meta property="og:site_name" content="Gareth's Engineering Blog"><meta property="og:image" content="https://gazsecops.github.io/og-image.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><meta property="article:published_time" content="2025-05-20 10:00:00 +0000 UTC"></head><body><div class="container center"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>gareth@blog:~$</div></a></div><div class=header__search><input type=text id=header-search placeholder="Quick search..." style="padding:5px 10px;background:#222;color:#eee;border:1px solid #444;border-radius:3px;font-size:14px;width:200px"></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;â–¾</li><li><ul class=menu__dropdown><li><a href=/topics/>Topics</a></li><li><a href=/posts/>All</a></li><li><a href=/series/>Series</a></li><li><a href=/tags/>Tags</a></li><li><a href=/archive/>Archive</a></li><li><a href=/search/>Search</a></li><li><a href=/about/>About</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/topics/>Topics</a></li><li><a href=/posts/>All</a></li><li><a href=/series/>Series</a></li><li><a href=/tags/>Tags</a></li><li><a href=/archive/>Archive</a></li><li><a href=/search/>Search</a></li><li><a href=/about/>About</a></li></ul></nav></header><script>(function(){const e=document.getElementById("header-search");if(!e)return;e.addEventListener("keydown",function(e){if(e.key==="Enter"){const e=this.value.trim();e&&(window.location.href="/search?q="+encodeURIComponent(e))}}),document.addEventListener("keydown",function(t){t.key==="/"&&!["INPUT","TEXTAREA"].includes(t.target.tagName)&&(t.preventDefault(),e.focus()),t.key==="Escape"&&t.target===e&&e.blur()})})()</script><style>.header__inner{display:flex;align-items:center;gap:20px}.header__search{flex:none}#header-search::placeholder{color:#666;font-style:italic}#header-search:focus{outline:none;border-color:#888}@media(max-width:684px){.header__search{display:none}}</style><div class=content><article class=post><h1 class=post-title><a href=https://gazsecops.github.io/posts/oauth2-security-pitfalls/>OAuth 2.0 Security: What Actually Breaks</a></h1><div class=post-meta><time class=post-date>2025-05-20</time><span class=post-author>Gareth</span><span class=post-reading-time>10 min read (2094 words)</span></div><span class=post-tags>#<a href=https://gazsecops.github.io/tags/security/>security</a>&nbsp;
#<a href=https://gazsecops.github.io/tags/oauth2/>oauth2</a>&nbsp;
#<a href=https://gazsecops.github.io/tags/authentication/>authentication</a>&nbsp;
#<a href=https://gazsecops.github.io/tags/web-security/>web-security</a>&nbsp;</span><div class=table-of-contents><h2>Table of Contents</h2><nav id=TableOfContents><ul><li><a href=#what-oauth-actually-does>What OAuth Actually Does</a></li><li><a href=#the-mistakes-that-matter>The Mistakes That Matter</a><ul><li><a href=#redirect-uri-validation>Redirect URI Validation</a></li><li><a href=#pkce-missing>PKCE Missing</a></li><li><a href=#state-parameter-omitted>State Parameter Omitted</a></li><li><a href=#token-storage-in-localstorage>Token Storage in LocalStorage</a></li><li><a href=#overly-permissive-scopes>Overly Permissive Scopes</a></li><li><a href=#refresh-token-rotation-not-implemented>Refresh Token Rotation Not Implemented</a></li></ul></li><li><a href=#openid-connect-vs-oauth-20>OpenID Connect vs OAuth 2.0</a><ul><li><a href=#the-bit-people-mess-up-id-token-validation>The Bit People Mess Up: ID Token Validation</a></li></ul></li><li><a href=#identity-providers-hosted-vs-self-hosted>Identity Providers: Hosted vs Self-Hosted</a></li><li><a href=#what-actually-happened>What Actually Happened</a></li><li><a href=#what-to-do>What To Do</a></li><li><a href=#the-boring-truth>The Boring Truth</a></li></ul></nav></div><div class=post-content><div><div class=dialogue><p><span class="speaker speaker-engineer">Engineer:</span> We need OAuth for the new API.</p><p><span class="speaker speaker-sysadmin">Sysadmin:</span> Have you implemented PKCE?</p><p><span class="speaker speaker-engineer">Engineer:</span> What&rsquo;s PKCE?</p><p><span class="speaker speaker-sysadmin">Sysadmin:</span> Proof Key for Code Exchange. Prevents authorisation code interception.</p><p><span class="speaker speaker-engineer">Engineer:</span> Is that the state parameter thing?</p><p><span class="speaker speaker-sysadmin">Sysadmin:</span> No, that&rsquo;s CSRF protection. Different problem.</p><p><span class="speaker speaker-engineer">Engineer:</span> &mldr;we might need to start over.</p></div><p>This conversation happens constantly. OAuth 2.0 is everywhere, but most implementations get it wrong. Not spectacularly wrong. Just wrong enough to be exploitable.</p><aside class=pullquote>"OAuth 2.0 isn't hard because the spec is complex. It's hard because the spec gives you enough rope to hang yourself, and most people do exactly that."</aside><p>The OAuth 2.0 specification is a framework, not a protocol. It gives you options. Most of those options are wrong for your use case. The security comes from knowing which options to pick and which to avoid.</p><h2 id=what-oauth-actually-does>What OAuth Actually Does<a href=#what-oauth-actually-does class=hanchor arialabel=Anchor>#</a></h2><p>OAuth 2.0 is authorization, not authentication. It lets one service act on your behalf without giving away your password.</p><p><strong>Example:</strong>
You use a photo printing service. It needs access to your photos stored on another service. OAuth lets you authorize the printer to access your photos without giving it your password.</p><p>That&rsquo;s it. That&rsquo;s what OAuth does.</p><p>Everything else - identity, user information, authentication - is built on top via OpenID Connect.</p><p><strong>Common confusion:</strong></p><div class=dialogue><p><span class="speaker speaker-engineer">Engineer:</span> We&rsquo;re using OAuth for login.</p><p><span class="speaker speaker-sysadmin">Sysadmin:</span> OAuth doesn&rsquo;t do login. It does authorization.</p><p><span class="speaker speaker-engineer">Engineer:</span> But Google OAuth gives us the user&rsquo;s email.</p><p><span class="speaker speaker-sysadmin">Sysadmin:</span> That&rsquo;s OpenID Connect. Built on OAuth, but adds authentication.</p><p><span class="speaker speaker-engineer">Engineer:</span> What&rsquo;s the difference?</p><p><span class="speaker speaker-sysadmin">Sysadmin:</span> OAuth: &ldquo;Can this app access your photos?&rdquo; OpenID Connect: &ldquo;Who are you?&rdquo;</p></div><p>Get this wrong and you&rsquo;re solving the wrong problem with the wrong tool.</p><h2 id=the-mistakes-that-matter>The Mistakes That Matter<a href=#the-mistakes-that-matter class=hanchor arialabel=Anchor>#</a></h2><h3 id=redirect-uri-validation>Redirect URI Validation<a href=#redirect-uri-validation class=hanchor arialabel=Anchor>#</a></h3><p><strong>The problem:</strong></p><p>OAuth works by redirecting users back to your application with an authorization code. If you don&rsquo;t validate the redirect URI strictly, attackers can steal these codes.</p><p><strong>What people do:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># Bad: Prefix matching</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>is_valid_redirect</span>(registered, requested):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> requested<span style=color:#f92672>.</span>startswith(registered)
</span></span></code></pre></div><p><strong>What happens:</strong></p><ul><li>Registered: <code>https://app.example.com/callback</code></li><li>Attack: <code>https://app.example.com/callback.attacker.com</code></li><li>Result: Code sent to attacker&rsquo;s domain</li></ul><p><strong>What works:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># Good: Exact matching</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>is_valid_redirect</span>(registered, requested):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> registered <span style=color:#f92672>==</span> requested
</span></span></code></pre></div><p>No wildcards. No substrings. Exact match.</p><p><strong>Real incident:</strong></p><p>Facebook&rsquo;s OAuth implementation (2017) used prefix matching. Researchers could steal access tokens by registering domains like <code>facebook.com.attacker.com</code> that matched the prefix check but redirected to attacker-controlled servers.</p><h3 id=pkce-missing>PKCE Missing<a href=#pkce-missing class=hanchor arialabel=Anchor>#</a></h3><p><strong>The problem:</strong></p><p>Authorization codes can be intercepted. Particularly on mobile apps or single-page applications. PKCE (Proof Key for Code Exchange) prevents the intercepted code from being useful.</p><p><strong>How it works:</strong></p><ol><li>Generate random string (code_verifier)</li><li>Hash it (code_challenge)</li><li>Send hash with authorization request</li><li>Send original string when exchanging code for token</li><li>Server verifies: hash of original matches stored hash</li></ol><p>If an attacker intercepts the authorization code, they don&rsquo;t have the original random string. The code is useless without it.</p><p><strong>Who needs PKCE:</strong></p><p>Everyone. Not just mobile apps.</p><p>The OAuth 2.1 draft spec makes PKCE mandatory for all clients. That&rsquo;s how important it is.</p><p><strong>Implementation:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#75715e>// Generate code verifier (random string)
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>generateCodeVerifier</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>array</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Uint8Array</span>(<span style=color:#ae81ff>32</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>crypto</span>.<span style=color:#a6e22e>getRandomValues</span>(<span style=color:#a6e22e>array</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>base64UrlEncode</span>(<span style=color:#a6e22e>array</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Generate code challenge (hash of verifier)
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>generateCodeChallenge</span>(<span style=color:#a6e22e>verifier</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>buffer</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>TextEncoder</span>().<span style=color:#a6e22e>encode</span>(<span style=color:#a6e22e>verifier</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>hash</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>crypto</span>.<span style=color:#a6e22e>subtle</span>.<span style=color:#a6e22e>digest</span>(<span style=color:#e6db74>&#39;SHA-256&#39;</span>, <span style=color:#a6e22e>buffer</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>base64UrlEncode</span>(<span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Uint8Array</span>(<span style=color:#a6e22e>hash</span>));
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Authorization request
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>verifier</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>generateCodeVerifier</span>();
</span></span><span style=display:flex><span><span style=color:#a6e22e>sessionStorage</span>.<span style=color:#a6e22e>setItem</span>(<span style=color:#e6db74>&#39;code_verifier&#39;</span>, <span style=color:#a6e22e>verifier</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>challenge</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>generateCodeChallenge</span>(<span style=color:#a6e22e>verifier</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>window.<span style=color:#a6e22e>location</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>`https://auth.example.com/authorize?`</span> <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>`client_id=</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>clientId</span><span style=color:#e6db74>}</span><span style=color:#e6db74>&amp;`</span> <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>`redirect_uri=</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>redirectUri</span><span style=color:#e6db74>}</span><span style=color:#e6db74>&amp;`</span> <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>`response_type=code&amp;`</span> <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>`code_challenge=</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>challenge</span><span style=color:#e6db74>}</span><span style=color:#e6db74>&amp;`</span> <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>`code_challenge_method=S256`</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Token exchange (later, in callback)
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>storedVerifier</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>sessionStorage</span>.<span style=color:#a6e22e>getItem</span>(<span style=color:#e6db74>&#39;code_verifier&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>fetch</span>(<span style=color:#e6db74>&#39;https://auth.example.com/token&#39;</span>, {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>method</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;POST&#39;</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>body</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>URLSearchParams</span>({
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>grant_type</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;authorization_code&#39;</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>code</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>code</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>redirect_uri</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>redirectUri</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>client_id</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>clientId</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>code_verifier</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>storedVerifier</span>
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><h3 id=state-parameter-omitted>State Parameter Omitted<a href=#state-parameter-omitted class=hanchor arialabel=Anchor>#</a></h3><p><strong>The problem:</strong></p><p>CSRF attacks on OAuth flows. Attacker tricks you into authorizing their malicious app, or linking their account to yours.</p><p><strong>How the attack works:</strong></p><ol><li>Attacker starts OAuth flow for your account</li><li>Attacker captures the authorization callback URL (with authorization code)</li><li>Attacker sends you that URL (phishing email, embedded in site, etc.)</li><li>You click it</li><li>Your browser sends the authorization code to the attacker&rsquo;s app</li><li>Attacker&rsquo;s app now has access to your account</li></ol><p><strong>What prevents it:</strong></p><p>The state parameter. Random value you generate, include in the authorization request, and verify in the callback.</p><p><strong>Implementation:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># Generate state</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> secrets
</span></span><span style=display:flex><span>state <span style=color:#f92672>=</span> secrets<span style=color:#f92672>.</span>token_urlsafe(<span style=color:#ae81ff>32</span>)
</span></span><span style=display:flex><span>session[<span style=color:#e6db74>&#39;oauth_state&#39;</span>] <span style=color:#f92672>=</span> state
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Authorization URL</span>
</span></span><span style=display:flex><span>auth_url <span style=color:#f92672>=</span> <span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;https://auth.example.com/authorize?&#34;</span> \
</span></span><span style=display:flex><span>           <span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;client_id=</span><span style=color:#e6db74>{</span>client_id<span style=color:#e6db74>}</span><span style=color:#e6db74>&amp;&#34;</span> \
</span></span><span style=display:flex><span>           <span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;redirect_uri=</span><span style=color:#e6db74>{</span>redirect_uri<span style=color:#e6db74>}</span><span style=color:#e6db74>&amp;&#34;</span> \
</span></span><span style=display:flex><span>           <span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;response_type=code&amp;&#34;</span> \
</span></span><span style=display:flex><span>           <span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;state=</span><span style=color:#e6db74>{</span>state<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Callback handler</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>callback</span>():
</span></span><span style=display:flex><span>    received_state <span style=color:#f92672>=</span> request<span style=color:#f92672>.</span>args<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#39;state&#39;</span>)
</span></span><span style=display:flex><span>    stored_state <span style=color:#f92672>=</span> session<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#39;oauth_state&#39;</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> received_state <span style=color:#f92672>or</span> received_state <span style=color:#f92672>!=</span> stored_state:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;Invalid state parameter&#34;</span>, <span style=color:#ae81ff>403</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e># Continue with token exchange</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>
</span></span></code></pre></div><p>Simple. Effective. Constantly forgotten.</p><h3 id=token-storage-in-localstorage>Token Storage in LocalStorage<a href=#token-storage-in-localstorage class=hanchor arialabel=Anchor>#</a></h3><p><strong>The problem:</strong></p><p>Access tokens stored in localStorage are accessible to any JavaScript running on the page. Including malicious scripts injected via XSS.</p><p><strong>What people do:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#75715e>// Bad: Token accessible to any script
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>localStorage</span>.<span style=color:#a6e22e>setItem</span>(<span style=color:#e6db74>&#39;access_token&#39;</span>, <span style=color:#a6e22e>token</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Later
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>token</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>localStorage</span>.<span style=color:#a6e22e>getItem</span>(<span style=color:#e6db74>&#39;access_token&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>fetch</span>(<span style=color:#e6db74>&#39;/api/data&#39;</span>, {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>headers</span><span style=color:#f92672>:</span> { <span style=color:#e6db74>&#39;Authorization&#39;</span><span style=color:#f92672>:</span> <span style=color:#e6db74>`Bearer </span><span style=color:#e6db74>${</span><span style=color:#a6e22e>token</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span> }
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p><strong>What happens:</strong></p><p>One XSS vulnerability anywhere on your site, and all tokens are compromised.</p><p><strong>What works:</strong></p><p>Store tokens server-side. Use HTTP-only cookies.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># Server-side (Python/Flask example)</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@app.route</span>(<span style=color:#e6db74>&#39;/auth/callback&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>callback</span>():
</span></span><span style=display:flex><span>    <span style=color:#75715e># Exchange code for tokens</span>
</span></span><span style=display:flex><span>    token_response <span style=color:#f92672>=</span> exchange_code_for_tokens(request<span style=color:#f92672>.</span>args<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#39;code&#39;</span>))
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e># Store tokens in session (server-side)</span>
</span></span><span style=display:flex><span>    session[<span style=color:#e6db74>&#39;access_token&#39;</span>] <span style=color:#f92672>=</span> token_response[<span style=color:#e6db74>&#39;access_token&#39;</span>]
</span></span><span style=display:flex><span>    session[<span style=color:#e6db74>&#39;refresh_token&#39;</span>] <span style=color:#f92672>=</span> token_response[<span style=color:#e6db74>&#39;refresh_token&#39;</span>]
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e># Redirect to app</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> redirect(<span style=color:#e6db74>&#39;/dashboard&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@app.route</span>(<span style=color:#e6db74>&#39;/api/data&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_data</span>():
</span></span><span style=display:flex><span>    <span style=color:#75715e># Retrieve token from session</span>
</span></span><span style=display:flex><span>    token <span style=color:#f92672>=</span> session<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#39;access_token&#39;</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e># Use token to call backend API</span>
</span></span><span style=display:flex><span>    response <span style=color:#f92672>=</span> requests<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#39;https://api.example.com/data&#39;</span>,
</span></span><span style=display:flex><span>                          headers<span style=color:#f92672>=</span>{<span style=color:#e6db74>&#39;Authorization&#39;</span>: <span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;Bearer </span><span style=color:#e6db74>{</span>token<span style=color:#e6db74>}</span><span style=color:#e6db74>&#39;</span>})
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> response<span style=color:#f92672>.</span>json()
</span></span></code></pre></div><p>Tokens never touch the browser. XSS can&rsquo;t steal them.</p><p><strong>Alternative for SPAs:</strong></p><p>Backend-for-Frontend (BFF) pattern. Your SPA talks to a thin backend you control. That backend handles OAuth and tokens. Browser only gets session cookies.</p><h3 id=overly-permissive-scopes>Overly Permissive Scopes<a href=#overly-permissive-scopes class=hanchor arialabel=Anchor>#</a></h3><p><strong>The problem:</strong></p><p>Requesting more permissions than you need. Increases damage if tokens are compromised. Makes users suspicious.</p><p><strong>What people do:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#75715e>// Bad: Requesting everything
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>scopes</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;read write delete admin user:email repo public_repo&#39;</span>;
</span></span></code></pre></div><p><strong>What works:</strong></p><p>Minimum necessary permissions.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#75715e>// Good: Minimal scopes
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>scopes</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;read:items user:email&#39;</span>;
</span></span></code></pre></div><p><strong>Real example:</strong></p><p>Cambridge Analytica accessed Facebook data through an app that requested excessive permissions. Users authorized a personality quiz that asked for access to their full profile, friend list, and timeline. That data was then used for purposes users never intended.</p><p>The lesson: Request only what you actually need. Users shouldn&rsquo;t have to trust you with their entire digital life to use your app.</p><h3 id=refresh-token-rotation-not-implemented>Refresh Token Rotation Not Implemented<a href=#refresh-token-rotation-not-implemented class=hanchor arialabel=Anchor>#</a></h3><p><strong>The problem:</strong></p><p>Refresh tokens are long-lived credentials. If stolen, they give persistent access.</p><p>Refresh token rotation limits this. Every time you use a refresh token to get a new access token, you also get a new refresh token. The old one is invalidated.</p><p><strong>Why it matters:</strong></p><p>Without rotation, a stolen refresh token works forever (or until it expires, which might be months).</p><p>With rotation, if an attacker uses a stolen refresh token, they get ONE new access token. Then their refresh token stops working. Your legitimate app tries to use its refresh token (the same one the attacker just used), and the server detects reuse.</p><p><strong>Detection:</strong></p><p>When refresh token reuse is detected, revoke ALL tokens for that session. Assume compromise.</p><p><strong>Implementation:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>handleTokenRefresh</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>refreshToken</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>FormValue</span>(<span style=color:#e6db74>&#34;refresh_token&#34;</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Validate refresh token</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>oldToken</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>validateRefreshToken</span>(<span style=color:#a6e22e>refreshToken</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Error</span>(<span style=color:#a6e22e>w</span>, <span style=color:#e6db74>&#34;Invalid refresh token&#34;</span>, <span style=color:#ae81ff>400</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Check for reuse (token already used before)</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>isTokenUsed</span>(<span style=color:#a6e22e>refreshToken</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// SECURITY BREACH: Revoke all tokens for this user</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>revokeAllTokensForUser</span>(<span style=color:#a6e22e>oldToken</span>.<span style=color:#a6e22e>UserID</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;Refresh token reuse detected: user=%s&#34;</span>, <span style=color:#a6e22e>oldToken</span>.<span style=color:#a6e22e>UserID</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Error</span>(<span style=color:#a6e22e>w</span>, <span style=color:#e6db74>&#34;Security violation&#34;</span>, <span style=color:#ae81ff>401</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Mark token as used</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>markTokenAsUsed</span>(<span style=color:#a6e22e>refreshToken</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Generate NEW refresh token and access token</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>newRefreshToken</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>generateRefreshToken</span>()
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>newAccessToken</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>generateAccessToken</span>(<span style=color:#a6e22e>oldToken</span>.<span style=color:#a6e22e>UserID</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Store new refresh token</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>storeRefreshToken</span>(<span style=color:#a6e22e>newRefreshToken</span>, <span style=color:#a6e22e>oldToken</span>.<span style=color:#a6e22e>UserID</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>json</span>.<span style=color:#a6e22e>NewEncoder</span>(<span style=color:#a6e22e>w</span>).<span style=color:#a6e22e>Encode</span>(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>string</span>{
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;access_token&#34;</span>: <span style=color:#a6e22e>newAccessToken</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;refresh_token&#34;</span>: <span style=color:#a6e22e>newRefreshToken</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;token_type&#34;</span>: <span style=color:#e6db74>&#34;bearer&#34;</span>,
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=openid-connect-vs-oauth-20>OpenID Connect vs OAuth 2.0<a href=#openid-connect-vs-oauth-20 class=hanchor arialabel=Anchor>#</a></h2><p>People confuse these constantly. They&rsquo;re related but different.</p><p><strong>OAuth 2.0:</strong></p><ul><li>Authorization (what can the app do?)</li><li>Gives you an access token</li><li>Access token lets app call APIs on your behalf</li><li>Doesn&rsquo;t tell you WHO the user is</li></ul><p><strong>OpenID Connect:</strong></p><ul><li>Authentication (who is the user?)</li><li>Built on top of OAuth 2.0</li><li>Adds ID token (tells you who the user is)</li><li>Adds UserInfo endpoint (get user details)</li></ul><p><strong>When to use which:</strong></p><p>OAuth 2.0: &ldquo;Let this app post to my social media&rdquo;
OpenID Connect: &ldquo;Log in with Google&rdquo;</p><p>If you&rsquo;re doing &ldquo;Sign in with X&rdquo;, you want OpenID Connect, not plain OAuth.</p><h3 id=the-bit-people-mess-up-id-token-validation>The Bit People Mess Up: ID Token Validation<a href=#the-bit-people-mess-up-id-token-validation class=hanchor arialabel=Anchor>#</a></h3><p>OIDC gives you an ID token (<code>id_token</code>). It&rsquo;s meant for your app.</p><p>The access token is meant for an API.</p><p>If you treat an access token as &ldquo;proof the user is Alice&rdquo;, you&rsquo;ll eventually accept a token that was never meant for you.</p><p>Minimum validation rules for an ID token:</p><ul><li>Verify signature using the IdP&rsquo;s JWKS</li><li>Check <code>iss</code> (issuer) matches your IdP</li><li>Check <code>aud</code> includes your client ID</li><li>Check <code>exp</code> is in the future</li><li>Check <code>nonce</code> matches what you generated for this login</li></ul><p>Example in Go using <code>go-oidc</code> (this verifies the signature, issuer, audience, and lets you check nonce):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>provider</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>oidc</span>.<span style=color:#a6e22e>NewProvider</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#e6db74>&#34;https://login.example.com&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>verifier</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>provider</span>.<span style=color:#a6e22e>Verifier</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>oidc</span>.<span style=color:#a6e22e>Config</span>{<span style=color:#a6e22e>ClientID</span>: <span style=color:#e6db74>&#34;your-client-id&#34;</span>})
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>rawIDToken</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>FormValue</span>(<span style=color:#e6db74>&#34;id_token&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>idToken</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>verifier</span>.<span style=color:#a6e22e>Verify</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>rawIDToken</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;invalid id_token: %w&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>claims</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Subject</span> <span style=color:#66d9ef>string</span> <span style=color:#e6db74>`json:&#34;sub&#34;`</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Email</span>   <span style=color:#66d9ef>string</span> <span style=color:#e6db74>`json:&#34;email&#34;`</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Nonce</span>   <span style=color:#66d9ef>string</span> <span style=color:#e6db74>`json:&#34;nonce&#34;`</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>idToken</span>.<span style=color:#a6e22e>Claims</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>claims</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>claims</span>.<span style=color:#a6e22e>Nonce</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>expectedNonceFromSession</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;nonce mismatch&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>If you don&rsquo;t know what a nonce is: it&rsquo;s the state parameter&rsquo;s cousin.
State stops CSRF in the redirect. Nonce stops replay in the ID token.</p><h2 id=identity-providers-hosted-vs-self-hosted>Identity Providers: Hosted vs Self-Hosted<a href=#identity-providers-hosted-vs-self-hosted class=hanchor arialabel=Anchor>#</a></h2><p><strong>Hosted (Auth0, Okta, etc.):</strong></p><p>Advantages:</p><ul><li>Someone else&rsquo;s problem</li><li>Professional security team</li><li>Compliance certifications</li><li>Works out of the box</li></ul><p>Disadvantages:</p><ul><li>Monthly costs (can be significant)</li><li>Vendor lock-in</li><li>Data stored with third party</li><li>Limited customization</li></ul><p><strong>Self-Hosted (Keycloak, etc.):</strong></p><p>Advantages:</p><ul><li>Complete control</li><li>No ongoing fees (just infrastructure)</li><li>Data stays on your servers</li><li>Full customization</li></ul><p>Disadvantages:</p><ul><li>You have to run it</li><li>Security is your responsibility</li><li>Updates are your problem</li><li>High availability is your problem</li></ul><p><strong>Most organizations should use hosted.</strong></p><p>Unless you have specific requirements (data sovereignty, extreme customization, huge scale), hosted is better. Running auth properly is hard. Let someone else do it.</p><h2 id=what-actually-happened>What Actually Happened<a href=#what-actually-happened class=hanchor arialabel=Anchor>#</a></h2><p><strong>Facebook (2018) - 50 million accounts compromised</strong></p><p>Access tokens exposed through &ldquo;View As&rdquo; feature. Tokens could be used to take over accounts completely.</p><p>Root cause: Token exposure in client-side code + insufficient token validation.</p><p><strong>Google Docs OAuth Phishing (2017) - 1 million users</strong></p><p>Attackers created an app named &ldquo;Google Docs&rdquo; (same name as the real service). Users authorized it thinking it was Google. App gained access to email and contacts.</p><p>Root cause: No verification that app names aren&rsquo;t impersonating official services.</p><p><strong>Dropbox (2016) - Redirect URI validation bypass</strong></p><p>Researchers found Dropbox accepted redirect URIs that matched by prefix. Could redirect to attacker-controlled sites.</p><p>Root cause: Prefix matching instead of exact matching for redirect URIs.</p><p><strong>Pattern:</strong></p><p>These aren&rsquo;t exotic attacks. They&rsquo;re basic implementation mistakes. Redirect URI validation. Token storage. Input validation. Fundamentals.</p><h2 id=what-to-do>What To Do<a href=#what-to-do class=hanchor arialabel=Anchor>#</a></h2><p><strong>For new implementations:</strong></p><ol><li>Use PKCE (even if you&rsquo;re not a mobile app)</li><li>Validate redirect URIs exactly</li><li>Use state parameter</li><li>Store tokens server-side (not localStorage)</li><li>Request minimal scopes</li><li>Implement refresh token rotation</li><li>Use HTTPS everywhere</li></ol><p><strong>For existing implementations:</strong></p><ol><li>Audit redirect URI validation</li><li>Check if PKCE is implemented</li><li>Verify state parameter is used and validated</li><li>Review token storage (is it in localStorage?)</li><li>Check scope requests (are they minimal?)</li><li>Test refresh token rotation</li></ol><p><strong>Testing:</strong></p><p>Don&rsquo;t trust your implementation without testing it.</p><p>Things worth testing (because they fail in real systems):</p><ul><li>Redirect URI mismatch: does it reject anything that&rsquo;s not an exact match?</li><li>Missing/invalid <code>state</code>: does the callback fail hard?</li><li>PKCE: can you complete the flow without a valid <code>code_verifier</code>?</li><li>Token storage: can any XSS grab a token (localStorage) or is it HttpOnly server-side?</li><li>Refresh token reuse: does the IdP revoke the session when reuse happens?</li><li>ID token validation: does your app reject wrong <code>iss</code>, wrong <code>aud</code>, expired tokens, and nonce mismatch?</li></ul><p>Tooling:</p><ul><li>Burp Suite to mess with redirects and parameters</li><li>A browser with devtools to confirm where tokens end up</li><li>Your IdP logs (sign-in logs and token issuance logs)</li></ul><p>Try to break it yourself before attackers do.</p><h2 id=the-boring-truth>The Boring Truth<a href=#the-boring-truth class=hanchor arialabel=Anchor>#</a></h2><p>OAuth 2.0 security isn&rsquo;t about exotic attacks or sophisticated defenses. It&rsquo;s about getting the basics right.</p><p>Most OAuth breaches happen because:</p><ul><li>Redirect URIs weren&rsquo;t validated properly</li><li>PKCE wasn&rsquo;t implemented</li><li>State parameter was missing</li><li>Tokens were stored in localStorage</li><li>Scopes were overly permissive</li></ul><p>Fix those five things and you&rsquo;re ahead of most implementations.</p><p>The OAuth spec gives you options. Most options are traps. The path to secure OAuth is knowing which options to avoid and which to always use.</p><p>PKCE: Always.
State parameter: Always.
Exact redirect URI matching: Always.
Server-side token storage: Always.
Minimal scopes: Always.</p><p>Everything else is details.</p></div></div><div class=related-posts style="margin-top:3rem;padding-top:2rem;border-top:1px solid #333"><h3>Related Posts</h3><ul style=list-style:none;padding:0><li style=margin-bottom:1rem><a href=https://gazsecops.github.io/posts/oauth2-vs-saml-differences/>OAuth2 vs SAML: Which One and Why?</a>
<span style=color:#999;font-size:.9rem>- 10 Nov 2025</span><div style=font-size:.85rem;color:#666;margin-top:.25rem><span style=margin-right:.5rem>#authentication</span>
<span style=margin-right:.5rem>#oauth2</span>
<span style=margin-right:.5rem>#saml</span>
<span style=margin-right:.5rem>#security</span>
<span style=margin-right:.5rem>#enterprise</span></div></li><li style=margin-bottom:1rem><a href=https://gazsecops.github.io/posts/oauth2-obo-flow-complete-guide/>OAuth2 On-Behalf-Of Flow: A Complete Guide for Microservices</a>
<span style=color:#999;font-size:.9rem>- 4 Feb 2026</span><div style=font-size:.85rem;color:#666;margin-top:.25rem><span style=margin-right:.5rem>#oauth2</span>
<span style=margin-right:.5rem>#security</span>
<span style=margin-right:.5rem>#microservices</span>
<span style=margin-right:.5rem>#authentication</span>
<span style=margin-right:.5rem>#authorization</span></div></li><li style=margin-bottom:1rem><a href=https://gazsecops.github.io/posts/security-as-code-beyond-scanning/>Beyond Scanning: What Security as Code Really Means</a>
<span style=color:#999;font-size:.9rem>- 22 Nov 2025</span><div style=font-size:.85rem;color:#666;margin-top:.25rem><span style=margin-right:.5rem>#security</span>
<span style=margin-right:.5rem>#devsecops</span>
<span style=margin-right:.5rem>#automation</span>
<span style=margin-right:.5rem>#culture</span>
<span style=margin-right:.5rem>#operations</span></div></li><li style=margin-bottom:1rem><a href=https://gazsecops.github.io/posts/penetration-testing-what-works/>Penetration Testing: What Actually Works vs What You Usually Get</a>
<span style=color:#999;font-size:.9rem>- 20 Nov 2025</span><div style=font-size:.85rem;color:#666;margin-top:.25rem><span style=margin-right:.5rem>#security</span>
<span style=margin-right:.5rem>#penetration-testing</span>
<span style=margin-right:.5rem>#red-team</span>
<span style=margin-right:.5rem>#operations</span>
<span style=margin-right:.5rem>#assessment</span></div></li><li style=margin-bottom:1rem><a href=https://gazsecops.github.io/posts/supply-chain-attacks-how-they-happen/>Supply Chain Attacks: How They Happen and What Actually Works to Stop Them</a>
<span style=color:#999;font-size:.9rem>- 10 Nov 2025</span><div style=font-size:.85rem;color:#666;margin-top:.25rem><span style=margin-right:.5rem>#security</span>
<span style=margin-right:.5rem>#supply-chain</span>
<span style=margin-right:.5rem>#dependencies</span>
<span style=margin-right:.5rem>#vulnerabilities</span></div></li></ul></div><div class=pagination><div class=pagination__title><span class=pagination__title-h></span><hr></div><div class=pagination__buttons><a href=https://gazsecops.github.io/posts/dns-security-what-actually-breaks/ class="button inline prev">&lt; [<span class=button__text>DNS Security: What Actually Breaks</span>]
</a>::
<a href=https://gazsecops.github.io/posts/chaos-engineering-security-tool/ class="button inline next">[<span class=button__text>Chaos Engineering as Security Tool: Breaking Things to Make Them Stronger</span>] ></a></div></div></article></div><footer class=footer><div class=footer__inner><div class=copyright><span>Â© 2026</span></div><div class=build-info><span class=build-commit>e733073</span><span class=build-date>2026-02-12 12:33 UTC</span></div></div></footer></div></body></html>