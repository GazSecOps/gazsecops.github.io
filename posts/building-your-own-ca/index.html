<!doctype html><html lang=en><head><title>Building Your Own CA: Guardrails, Browser Trust, and Why Most Internal PKI is Broken :: Gareth's Engineering Blog</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content=" Management: We just need to issue some internal certs. How hard can it be?
Sysadmin: Hard enough that you&rsquo;ll be arguing about wildcards and trust stores in 18 months.
Famous last words. Eighteen months later, you&rsquo;re dealing with wildcard certs everywhere, browsers rejecting perfectly valid certificates, and nobody understands why the monitoring system stopped working after a cert renewal.
Internal PKI isn&rsquo;t hard because the cryptography is complex. It&rsquo;s hard because most organizations skip the guardrails that make PKI safe to operate at scale.
&#34;A CA without constraints is like giving everyone admin access and hoping they'll be responsible. Works fine until it doesn't.&#34; This is about building internal PKI properly. Not the minimum viable certificate authority. The kind that doesn&rsquo;t explode when someone makes a mistake.
"><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://gazsecops.github.io/posts/building-your-own-ca/><link rel=stylesheet href=https://gazsecops.github.io/css/extended.min.c658c723e006469d82f697e19c5338967fad12c57650bdd915bacf9cfbe2cc38.css><link rel=stylesheet href=https://gazsecops.github.io/css/buttons.min.86f6b4c106b6c6eb690ae5203d36b442c1f66f718ff4e8164fa86cf6c61ad641.css><link rel=stylesheet href=https://gazsecops.github.io/css/code.min.d529ea4b2fb8d34328d7d31afc5466d5f7bc2f0bc9abdd98b69385335d7baee4.css><link rel=stylesheet href=https://gazsecops.github.io/css/fonts.min.5bb7ed13e1d00d8ff39ea84af26737007eb5051b157b86fc24487c94f3dc8bbe.css><link rel=stylesheet href=https://gazsecops.github.io/css/footer.min.eb8dfc2c6a7eafa36cd3ba92d63e69e849e2200e0002a228d137f236b09ecd75.css><link rel=stylesheet href=https://gazsecops.github.io/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css><link rel=stylesheet href=https://gazsecops.github.io/css/header.min.75c7eb0e2872d95ff48109c6647d0223a38db52e2561dd87966eb5fc7c6bdac6.css><link rel=stylesheet href=https://gazsecops.github.io/css/main.min.36833afd348409fc6c3d09d0897c5833d9d5bf1ff31f5e60ea3ee42ce2b1268c.css><link rel=stylesheet href=https://gazsecops.github.io/css/menu.min.3c17467ebeb3d38663dce68f71f519901124fa5cbb4519b2fb0667a21e9aca39.css><link rel=stylesheet href=https://gazsecops.github.io/css/pagination.min.bbb986dbce00a5ce5aca0504b7925fc1c581992a4bf57f163e5d69cc1db7d836.css><link rel=stylesheet href=https://gazsecops.github.io/css/post.min.e6dddd258e64c83e05cec0cd49c05216742d42fc8ecbfbe6b67083412b609bd3.css><link rel=stylesheet href=https://gazsecops.github.io/css/syntax.min.a0773cce9310cb6d8ed23e50f005448facf29a53001b57e038828daa466b25c0.css><link rel=stylesheet href=https://gazsecops.github.io/css/terminal.min.e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css><link rel=stylesheet href=https://gazsecops.github.io/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css><link rel="shortcut icon" href=https://gazsecops.github.io/favicon.png><link rel=apple-touch-icon href=https://gazsecops.github.io/apple-touch-icon.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Building Your Own CA: Guardrails, Browser Trust, and Why Most Internal PKI is Broken"><meta property="og:description" content=" Management: We just need to issue some internal certs. How hard can it be?
Sysadmin: Hard enough that you&rsquo;ll be arguing about wildcards and trust stores in 18 months.
Famous last words. Eighteen months later, you&rsquo;re dealing with wildcard certs everywhere, browsers rejecting perfectly valid certificates, and nobody understands why the monitoring system stopped working after a cert renewal.
Internal PKI isn&rsquo;t hard because the cryptography is complex. It&rsquo;s hard because most organizations skip the guardrails that make PKI safe to operate at scale.
&#34;A CA without constraints is like giving everyone admin access and hoping they'll be responsible. Works fine until it doesn't.&#34; This is about building internal PKI properly. Not the minimum viable certificate authority. The kind that doesn&rsquo;t explode when someone makes a mistake.
"><meta property="og:url" content="https://gazsecops.github.io/posts/building-your-own-ca/"><meta property="og:site_name" content="Gareth's Engineering Blog"><meta property="og:image" content="https://gazsecops.github.io/og-image.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><meta property="article:published_time" content="2025-10-15 10:00:00 +0000 UTC"></head><body><div class="container center"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>gareth@blog:~$</div></a></div><div class=header__search><input type=text id=header-search placeholder="Quick search..." style="padding:5px 10px;background:#222;color:#eee;border:1px solid #444;border-radius:3px;font-size:14px;width:200px"></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/topics/>Topics</a></li><li><a href=/posts/>All</a></li><li><a href=/series/>Series</a></li><li><a href=/tags/>Tags</a></li><li><a href=/archive/>Archive</a></li><li><a href=/search/>Search</a></li><li><a href=/about/>About</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/topics/>Topics</a></li><li><a href=/posts/>All</a></li><li><a href=/series/>Series</a></li><li><a href=/tags/>Tags</a></li><li><a href=/archive/>Archive</a></li><li><a href=/search/>Search</a></li><li><a href=/about/>About</a></li></ul></nav></header><script>(function(){const e=document.getElementById("header-search");if(!e)return;e.addEventListener("keydown",function(e){if(e.key==="Enter"){const e=this.value.trim();e&&(window.location.href="/search?q="+encodeURIComponent(e))}}),document.addEventListener("keydown",function(t){t.key==="/"&&!["INPUT","TEXTAREA"].includes(t.target.tagName)&&(t.preventDefault(),e.focus()),t.key==="Escape"&&t.target===e&&e.blur()})})()</script><style>.header__inner{display:flex;align-items:center;gap:20px}.header__search{flex:none}#header-search::placeholder{color:#666;font-style:italic}#header-search:focus{outline:none;border-color:#888}@media(max-width:684px){.header__search{display:none}}</style><div class=content><article class=post><h1 class=post-title><a href=https://gazsecops.github.io/posts/building-your-own-ca/>Building Your Own CA: Guardrails, Browser Trust, and Why Most Internal PKI is Broken</a></h1><div class=post-meta><time class=post-date>2025-10-15</time><span class=post-author>Gareth</span><span class=post-reading-time>13 min read (2713 words)</span></div><span class=post-tags>#<a href=https://gazsecops.github.io/tags/pki/>pki</a>&nbsp;
#<a href=https://gazsecops.github.io/tags/security/>security</a>&nbsp;
#<a href=https://gazsecops.github.io/tags/tls/>tls</a>&nbsp;
#<a href=https://gazsecops.github.io/tags/certificates/>certificates</a>&nbsp;
#<a href=https://gazsecops.github.io/tags/infrastructure/>infrastructure</a>&nbsp;</span><div class=table-of-contents><h2>Table of Contents</h2><nav id=TableOfContents><ul><li><a href=#the-problem-with-most-internal-pki>The Problem With Most Internal PKI</a></li><li><a href=#web-pki-vs-internal-pki>Web PKI vs Internal PKI</a></li><li><a href=#the-guardrails-you-need>The Guardrails You Need</a><ul><li><a href=#1-name-constraints>1. Name Constraints</a></li><li><a href=#2-extended-key-usage-eku>2. Extended Key Usage (EKU)</a></li><li><a href=#3-key-usage-ku>3. Key Usage (KU)</a></li><li><a href=#4-path-length-constraints>4. Path Length Constraints</a></li><li><a href=#5-validity-periods>5. Validity Periods</a></li></ul></li><li><a href=#browser-behavior-and-trust>Browser Behavior and Trust</a><ul><li><a href=#installing-trust-the-bit-everyone-forgets>Installing Trust (The Bit Everyone Forgets)</a></li></ul></li><li><a href=#common-mistakes-and-how-to-avoid-them>Common Mistakes and How to Avoid Them</a><ul><li><a href=#mistake-1-wildcard-certificates-everywhere>Mistake 1: Wildcard Certificates Everywhere</a></li><li><a href=#mistake-2-no-certificate-inventory>Mistake 2: No Certificate Inventory</a></li><li><a href=#mistake-3-manual-renewal-process>Mistake 3: Manual Renewal Process</a></li><li><a href=#mistake-4-private-keys-stored-in-git>Mistake 4: Private Keys Stored in Git</a></li><li><a href=#mistake-5-no-revocation-strategy>Mistake 5: No Revocation Strategy</a></li></ul></li><li><a href=#practical-implementation>Practical Implementation</a><ul><li><a href=#architecture>Architecture</a></li><li><a href=#tooling>Tooling</a></li><li><a href=#key-ceremonies>Key Ceremonies</a></li></ul></li><li><a href=#monitoring-and-maintenance>Monitoring and Maintenance</a><ul><li><a href=#revocation-that-people-actually-use>Revocation That People Actually Use</a></li></ul></li><li><a href=#when-things-go-wrong>When Things Go Wrong</a><ul><li><a href=#compromised-private-key>Compromised Private Key</a></li><li><a href=#expired-root-certificate>Expired Root Certificate</a></li><li><a href=#lost-private-key>Lost Private Key</a></li></ul></li><li><a href=#compliance-and-audit>Compliance and Audit</a></li><li><a href=#summary>Summary</a></li></ul></nav></div><div class=post-content><div><div class=dialogue><p><span class="speaker speaker-management">Management:</span> We just need to issue some internal certs. How hard can it be?</p><p><span class="speaker speaker-sysadmin">Sysadmin:</span> Hard enough that you&rsquo;ll be arguing about wildcards and trust stores in 18 months.</p></div><p>Famous last words. Eighteen months later, you&rsquo;re dealing with wildcard certs everywhere, browsers rejecting perfectly valid certificates, and nobody understands why the monitoring system stopped working after a cert renewal.</p><p>Internal PKI isn&rsquo;t hard because the cryptography is complex. It&rsquo;s hard because most organizations skip the guardrails that make PKI safe to operate at scale.</p><aside class=pullquote>"A CA without constraints is like giving everyone admin access and hoping they'll be responsible. Works fine until it doesn't."</aside><p>This is about building internal PKI properly. Not the minimum viable certificate authority. The kind that doesn&rsquo;t explode when someone makes a mistake.</p><h2 id=the-problem-with-most-internal-pki>The Problem With Most Internal PKI<a href=#the-problem-with-most-internal-pki class=hanchor arialabel=Anchor>#</a></h2><p>I&rsquo;ve seen this pattern at dozens of organizations:</p><ol><li>Team needs internal TLS certificates</li><li>Someone spins up a CA (OpenSSL, easy-rsa, whatever)</li><li>CA has no constraints, no guardrails, no policies</li><li>Wildcard cert gets issued for <code>*.company.com</code></li><li>Wildcard cert gets copied everywhere</li><li>Cert expires, everything breaks</li><li>Or worse: cert gets leaked, nobody knows where it&rsquo;s used</li></ol><p>The problem isn&rsquo;t the CA itself. The problem is treating internal PKI as &ldquo;just some certs&rdquo; instead of critical security infrastructure.</p><h2 id=web-pki-vs-internal-pki>Web PKI vs Internal PKI<a href=#web-pki-vs-internal-pki class=hanchor arialabel=Anchor>#</a></h2><p>Let&rsquo;s start with what you&rsquo;re NOT building: a publicly-trusted CA.</p><p><strong>Web PKI (public CAs):</strong></p><ul><li>Trusted by browsers out of the box</li><li>Subject to CA/Browser Forum (CABF) rules</li><li>Requires WebTrust or ETSI audits</li><li>Maximum 398-day certificate validity</li><li>Certificate Transparency (CT) logs mandatory</li><li>OCSP or CRL distribution required</li><li>Heavy compliance burden</li></ul><p><strong>Internal PKI (what you&rsquo;re building):</strong></p><ul><li>Not trusted by browsers by default</li><li>No mandatory audits</li><li>You set validity periods</li><li>No CT logs required</li><li>You decide revocation strategy</li><li>Lighter compliance burden</li></ul><p>But here&rsquo;s the trap: just because you CAN skip Web PKI rules doesn&rsquo;t mean you SHOULD.</p><p>Modern internal PKI should adopt the same guardrails as Web PKI. Not because browsers require it. Because these guardrails prevent catastrophic mistakes.</p><h2 id=the-guardrails-you-need>The Guardrails You Need<a href=#the-guardrails-you-need class=hanchor arialabel=Anchor>#</a></h2><h3 id=1-name-constraints>1. Name Constraints<a href=#1-name-constraints class=hanchor arialabel=Anchor>#</a></h3><p><strong>What they do:</strong> Restrict which domains or IP ranges your CA can issue certificates for.</p><p><strong>Why you need them:</strong> Without name constraints, your internal CA can issue certificates for ANY domain. Including <code>google.com</code>, <code>amazon.com</code>, or your competitor&rsquo;s domain.</p><p>&ldquo;But we&rsquo;d never issue for external domains!&rdquo;</p><p>Mistakes happen. Automated systems misfire. Attackers compromise intermediates. Name constraints prevent these mistakes from becoming incidents.</p><p><strong>Example name constraints:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-fallback data-lang=fallback><span style=display:flex><span>Permitted:
</span></span><span style=display:flex><span>  DNS: .internal.company.com
</span></span><span style=display:flex><span>  DNS: .svc.cluster.local
</span></span><span style=display:flex><span>  IP: 10.0.0.0/8
</span></span><span style=display:flex><span>  IP: 172.16.0.0/12
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Excluded:
</span></span><span style=display:flex><span>  DNS: .com
</span></span><span style=display:flex><span>  DNS: .net
</span></span><span style=display:flex><span>  DNS: .org
</span></span><span style=display:flex><span>  DNS: .uk
</span></span></code></pre></div><p>This CA can ONLY issue for internal domains and RFC 1918 IP ranges. Cannot issue for public domains. Cannot issue for external IPs.</p><p><strong>Where to apply constraints:</strong></p><ul><li>NOT on the root CA (too restrictive, hard to fix)</li><li>ON intermediate CAs (perfect balance)</li><li>Different intermediates for different namespaces</li></ul><p>I&rsquo;ve seen organizations with:</p><ul><li>Intermediate 1: <code>.internal.company.com</code> only</li><li>Intermediate 2: <code>.svc.cluster.local</code> (Kubernetes)</li><li>Intermediate 3: <code>10.0.0.0/8</code> (infrastructure)</li></ul><p>Each intermediate can only issue for its designated namespace. Compromise of one doesn&rsquo;t affect others.</p><p><strong>What this looks like in OpenSSL:</strong></p><p>If you&rsquo;re signing an intermediate with OpenSSL, you can enforce name constraints in the intermediate certificate.</p><p>Example <code>nameConstraints</code> extension:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-ini data-lang=ini><span style=display:flex><span><span style=color:#75715e># intermediate.ext (snippet)</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>basicConstraints</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>critical,CA:true,pathlen:0</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>keyUsage</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>critical,keyCertSign,cRLSign</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>nameConstraints</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>critical,@nc</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>[nc]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>permitted;DNS.0</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>.internal.company.com</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>permitted;DNS.1</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>.svc.cluster.local</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>permitted;IP.0</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>10.0.0.0/255.0.0.0</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>permitted;IP.1</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>172.16.0.0/255.240.0.0</span>
</span></span></code></pre></div><p>If you&rsquo;ve never done this before: test it. Clients vary in how they handle name constraints. &ldquo;We put it in the cert&rdquo; is not the same as &ldquo;it actually blocks issuance/misuse&rdquo;.</p><h3 id=2-extended-key-usage-eku>2. Extended Key Usage (EKU)<a href=#2-extended-key-usage-eku class=hanchor arialabel=Anchor>#</a></h3><p><strong>What it does:</strong> Defines what a certificate can be used for.</p><p>Common EKU values:</p><ul><li><code>TLS Web Server Authentication</code> - HTTPS servers</li><li><code>TLS Web Client Authentication</code> - Client certificates</li><li><code>Code Signing</code> - Signing binaries</li><li><code>Email Protection</code> - S/MIME</li><li><code>Time Stamping</code> - Timestamping services</li></ul><p><strong>Why you need it:</strong> A certificate intended for TLS servers shouldn&rsquo;t be usable for code signing. Or client authentication. Or email encryption.</p><p>Without EKU restrictions:</p><ul><li>Server cert gets copied to developer laptop for client auth</li><li>Same cert used for TLS server AND code signing</li><li>Cert intended for staging ends up in production</li></ul><p><strong>Example:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-fallback data-lang=fallback><span style=display:flex><span># Server certificate
</span></span><span style=display:flex><span>EKU: TLS Web Server Authentication
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span># Client certificate  
</span></span><span style=display:flex><span>EKU: TLS Web Client Authentication
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span># Intermediate CA
</span></span><span style=display:flex><span>EKU: Certificate Sign, CRL Sign
</span></span></code></pre></div><p>Be specific. One purpose per certificate. Makes revocation easier (you know exactly what breaks).</p><h3 id=3-key-usage-ku>3. Key Usage (KU)<a href=#3-key-usage-ku class=hanchor arialabel=Anchor>#</a></h3><p>Works alongside EKU. Defines cryptographic operations allowed.</p><p>Common KU values:</p><ul><li><code>Digital Signature</code> - Can sign data</li><li><code>Key Encipherment</code> - Can encrypt session keys</li><li><code>Key Agreement</code> - Can perform key agreement</li><li><code>Certificate Sign</code> - Can sign certificates (CAs only)</li><li><code>CRL Sign</code> - Can sign CRLs (CAs only)</li></ul><p><strong>Leaf certificate example:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-fallback data-lang=fallback><span style=display:flex><span>KU: Digital Signature, Key Encipherment
</span></span><span style=display:flex><span>EKU: TLS Web Server Authentication
</span></span></code></pre></div><p>Can do TLS handshakes. Cannot sign other certificates. Cannot sign CRLs.</p><p><strong>CA certificate example:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-fallback data-lang=fallback><span style=display:flex><span>KU: Certificate Sign, CRL Sign
</span></span><span style=display:flex><span>Critical: Yes
</span></span></code></pre></div><p>Can sign certificates and CRLs. Cannot be used for TLS directly. Critical flag means clients MUST understand this extension.</p><h3 id=4-path-length-constraints>4. Path Length Constraints<a href=#4-path-length-constraints class=hanchor arialabel=Anchor>#</a></h3><p><strong>What it does:</strong> Controls how many intermediate CAs can exist below this CA.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-fallback data-lang=fallback><span style=display:flex><span>Basic Constraints:
</span></span><span style=display:flex><span>  CA: TRUE
</span></span><span style=display:flex><span>  pathlen: 1
</span></span></code></pre></div><p>This CA can issue one level of intermediates. Those intermediates cannot issue further intermediates (their pathlen would be 0).</p><p><strong>Why you need it:</strong> Prevents rogue teams from spinning up their own sub-CAs without oversight.</p><p>Typical structure:</p><ul><li>Root CA: <code>pathlen: 2</code> (can issue intermediates that issue intermediates)</li><li>Intermediate CA: <code>pathlen: 0</code> (cannot issue further intermediates)</li><li>Leaf certificates: Not a CA</li></ul><p>Without path length constraints, any intermediate can create its own subordinate hierarchy. Compromised intermediate = uncontrolled certificate issuance.</p><h3 id=5-validity-periods>5. Validity Periods<a href=#5-validity-periods class=hanchor arialabel=Anchor>#</a></h3><p><strong>Recommended limits:</strong></p><ul><li>Root CA: 20 years (rarely changes, pain to replace)</li><li>Intermediate CA: 5 years (balanced between stability and risk)</li><li>Leaf certificates: 30-90 days (short-lived, automated renewal)</li></ul><p>&ldquo;But Web PKI allows 398 days!&rdquo;</p><p>You can do better. Internal PKI with automation should use short-lived certificates:</p><p><strong>Benefits of 30-day certificates:</strong></p><ul><li>Compromised cert expires quickly</li><li>Revocation less critical (just wait for expiry)</li><li>Forces automation (manual renewal doesn&rsquo;t scale)</li><li>Leaked private keys have limited window</li></ul><p><strong>Objections I&rsquo;ve heard:</strong></p><div class=dialogue><p><span class="speaker speaker-engineer">Engineer:</span> 30 days is too short. What if automation breaks?</p><p><span class="speaker speaker-sysadmin">Sysadmin:</span> Then you fix automation. That&rsquo;s the point. Forces you to have working automation.</p><p><span class="speaker speaker-engineer">Engineer:</span> But manual renewal worked fine for 3-year certs.</p><p><span class="speaker speaker-sysadmin">Sysadmin:</span> Until someone left the company and nobody knew where certs were deployed. Then everything broke. Short certs force you to track them.</p></div><p>Short-lived certificates are a feature, not a bug. They force operational discipline.</p><h2 id=browser-behavior-and-trust>Browser Behavior and Trust<a href=#browser-behavior-and-trust class=hanchor arialabel=Anchor>#</a></h2><p>Your internal CA will NOT be trusted by browsers by default. This is expected.</p><p><strong>Options for trust:</strong></p><ol><li><strong>Install root CA in OS trust store</strong> - Works for corporate managed devices</li><li><strong>Configure application to trust CA</strong> - mTLS, API clients, internal tools</li><li><strong>Don&rsquo;t use it for browser-facing services</strong> - Use Let&rsquo;s Encrypt or public CA instead</li></ol><p><strong>What breaks if you try to use internal CA for public services:</strong></p><ul><li>Browsers reject certificates (unknown CA)</li><li>Mobile apps fail to connect</li><li>Third-party integrations break</li><li>Certificate Transparency checks fail</li><li>Customers see scary warnings</li></ul><p>Internal CA is for INTERNAL services. If it touches the public internet, use a public CA.</p><h3 id=installing-trust-the-bit-everyone-forgets>Installing Trust (The Bit Everyone Forgets)<a href=#installing-trust-the-bit-everyone-forgets class=hanchor arialabel=Anchor>#</a></h3><p>If you&rsquo;re using an internal CA for browser-facing internal services, you need the root CA in the trust store.</p><p>Do this with your device management tooling (MDM / Group Policy / whatever). But for one-off testing, here are the usual commands.</p><p>Debian/Ubuntu:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>sudo install -m <span style=color:#ae81ff>0644</span> root-ca.crt /usr/local/share/ca-certificates/company-root-ca.crt
</span></span><span style=display:flex><span>sudo update-ca-certificates
</span></span></code></pre></div><p>RHEL/CentOS/Fedora:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>sudo install -m <span style=color:#ae81ff>0644</span> root-ca.crt /etc/pki/ca-trust/source/anchors/company-root-ca.crt
</span></span><span style=display:flex><span>sudo update-ca-trust
</span></span></code></pre></div><p>macOS:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>sudo security add-trusted-cert -d -r trustRoot -k /Library/Keychains/System.keychain root-ca.crt
</span></span></code></pre></div><p>Windows (elevated prompt):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bat data-lang=bat><span style=display:flex><span>certutil -addstore -f Root root-ca.crt
</span></span></code></pre></div><p>If that made you wince, good. Trust distribution is operational work. Treat it like a rollout, not a copy-paste job.</p><h2 id=common-mistakes-and-how-to-avoid-them>Common Mistakes and How to Avoid Them<a href=#common-mistakes-and-how-to-avoid-them class=hanchor arialabel=Anchor>#</a></h2><h3 id=mistake-1-wildcard-certificates-everywhere>Mistake 1: Wildcard Certificates Everywhere<a href=#mistake-1-wildcard-certificates-everywhere class=hanchor arialabel=Anchor>#</a></h3><p>&ldquo;Let&rsquo;s just issue <code>*.company.com</code> and use it everywhere!&rdquo;</p><p>No.</p><p>Problems with wildcards:</p><ul><li>Single certificate covers everything (huge blast radius)</li><li>Gets copied everywhere (tracking becomes impossible)</li><li>Compromised cert affects all subdomains</li><li>Revocation impacts everything simultaneously</li><li>No way to know what&rsquo;s using it</li></ul><p>Better approach:</p><ul><li>Specific certificates per service</li><li>Automation handles issuance</li><li>Centralized tracking of what&rsquo;s deployed where</li><li>Revocation affects only one service</li></ul><h3 id=mistake-2-no-certificate-inventory>Mistake 2: No Certificate Inventory<a href=#mistake-2-no-certificate-inventory class=hanchor arialabel=Anchor>#</a></h3><p>&ldquo;Where are all our certificates?&rdquo;</p><p>&ldquo;Um&mldr;&rdquo;</p><p>If you can&rsquo;t list every certificate issued by your CA, you have a problem.</p><p><strong>Minimum tracking needed:</strong></p><ul><li>Certificate serial number</li><li>Subject (CN, SANs)</li><li>Issued to (team, service, system)</li><li>Expiry date</li><li>Current status (valid, revoked, expired)</li><li>Renewal automation status</li></ul><p>I&rsquo;ve seen organizations with thousands of certificates and zero inventory. Certificate expires, nobody knows where it&rsquo;s used, services break, firefighting ensues.</p><h3 id=mistake-3-manual-renewal-process>Mistake 3: Manual Renewal Process<a href=#mistake-3-manual-renewal-process class=hanchor arialabel=Anchor>#</a></h3><p>&ldquo;Just set a calendar reminder to renew.&rdquo;</p><p>This doesn&rsquo;t scale. This WILL fail.</p><p>At 10 certificates: Manual renewal barely works
At 100 certificates: Manual renewal constantly breaks
At 1000 certificates: Manual renewal is impossible</p><p><strong>Automation requirements:</strong></p><ul><li>Automatic certificate renewal before expiry</li><li>Monitoring of renewal success/failure</li><li>Alerting when renewal fails</li><li>Rollback plan when new cert breaks service</li><li>Testing of new certificates before deployment</li></ul><p>If you&rsquo;re renewing certificates manually, you&rsquo;re doing it wrong.</p><h3 id=mistake-4-private-keys-stored-in-git>Mistake 4: Private Keys Stored in Git<a href=#mistake-4-private-keys-stored-in-git class=hanchor arialabel=Anchor>#</a></h3><p>&ldquo;Let&rsquo;s commit the cert and key to the repo for easy deployment.&rdquo;</p><p>No. Never. Absolutely not.</p><p>Problems:</p><ul><li>Git history persists forever (even if you delete the file)</li><li>Everyone with repo access has the private key</li><li>Compromised key can&rsquo;t be uncompromised</li><li>Rotation becomes impossible</li></ul><p><strong>Proper key storage:</strong></p><ul><li>HSM for CA keys (hardware security module)</li><li>Secrets management for service keys (Vault, KMS, etc.)</li><li>Automated rotation</li><li>No keys in version control, ever</li></ul><h3 id=mistake-5-no-revocation-strategy>Mistake 5: No Revocation Strategy<a href=#mistake-5-no-revocation-strategy class=hanchor arialabel=Anchor>#</a></h3><p>&ldquo;We&rsquo;ll just wait for the cert to expire.&rdquo;</p><p>What if:</p><ul><li>Private key is compromised</li><li>Service is decommissioned</li><li>Certificate was issued incorrectly</li><li>Compliance requires immediate revocation</li></ul><p>You need revocation that works:</p><p><strong>OCSP (Online Certificate Status Protocol):</strong></p><ul><li>Real-time certificate status checks</li><li>Requires OCSP responder infrastructure</li><li>Privacy concerns (CA knows when cert is checked)</li></ul><p><strong>CRL (Certificate Revocation List):</strong></p><ul><li>Periodically updated list of revoked certs</li><li>Simpler to implement</li><li>Clients need to fetch and cache CRLs</li><li>Latency between revocation and enforcement</li></ul><p><strong>OCSP Stapling:</strong></p><ul><li>Server fetches OCSP response</li><li>Includes response in TLS handshake</li><li>Reduces privacy concerns</li><li>Better performance</li></ul><p>For internal PKI, CRL is often sufficient. For high-security environments, OCSP with stapling.</p><h2 id=practical-implementation>Practical Implementation<a href=#practical-implementation class=hanchor arialabel=Anchor>#</a></h2><h3 id=architecture>Architecture<a href=#architecture class=hanchor arialabel=Anchor>#</a></h3><p><strong>Three-tier hierarchy:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-fallback data-lang=fallback><span style=display:flex><span>Root CA (offline, air-gapped)
</span></span><span style=display:flex><span>  |
</span></span><span style=display:flex><span>  +-- Intermediate CA 1 (.internal.company.com)
</span></span><span style=display:flex><span>  |     |
</span></span><span style=display:flex><span>  |     +-- Leaf certificates
</span></span><span style=display:flex><span>  |
</span></span><span style=display:flex><span>  +-- Intermediate CA 2 (.svc.cluster.local)
</span></span><span style=display:flex><span>        |
</span></span><span style=display:flex><span>        +-- Leaf certificates
</span></span></code></pre></div><p><strong>Root CA characteristics:</strong></p><ul><li>Kept offline (air-gapped if possible)</li><li>Only used to sign intermediates</li><li>20-year validity</li><li>Strong key protection (HSM)</li></ul><p><strong>Intermediate CA characteristics:</strong></p><ul><li>Online, automated issuance</li><li>5-year validity</li><li>Name constraints applied</li><li>Path length = 0</li><li>Specific EKU restrictions</li></ul><p><strong>Leaf certificates:</strong></p><ul><li>30-90 day validity</li><li>Automated renewal</li><li>Specific to single service</li><li>Monitored for expiry</li></ul><h3 id=tooling>Tooling<a href=#tooling class=hanchor arialabel=Anchor>#</a></h3><p><strong>Don&rsquo;t roll your own CA</strong> (unless you really know what you&rsquo;re doing).</p><p>Modern options:</p><ul><li><strong>Smallstep</strong> - Excellent for internal PKI, good defaults</li><li><strong>HashiCorp Vault PKI</strong> - If you&rsquo;re already using Vault</li><li><strong>AWS Certificate Manager Private CA</strong> - Managed service</li><li><strong>GCP Certificate Authority Service</strong> - Another managed option</li></ul><p>These tools provide:</p><ul><li>Proper constraint handling</li><li>ACME protocol support (Let&rsquo;s Encrypt-style automation)</li><li>Certificate lifecycle management</li><li>Audit logging</li><li>Revocation infrastructure</li></ul><p>If you want the practical setup steps, I wrote them up here:</p><ul><li><a href=/posts/stepca-running-internal-pki/>Smallstep step-ca: Running Internal PKI Without Losing Your Mind</a></li></ul><p><strong>If you must use OpenSSL:</strong></p><ul><li>Use configuration files for constraints</li><li>Script everything (manual commands breed mistakes)</li><li>Test constraints before issuing production certs</li><li>Maintain detailed documentation</li></ul><h3 id=key-ceremonies>Key Ceremonies<a href=#key-ceremonies class=hanchor arialabel=Anchor>#</a></h3><p>For the root CA key generation, be paranoid:</p><p><strong>Minimum ceremony:</strong></p><ul><li>Offline computer (air-gapped)</li><li>Documented witness (2+ people present)</li><li>Video recording of process</li><li>Hardware random number generator</li><li>Secure storage (HSM or encrypted offline storage)</li></ul><p><strong>Steps:</strong></p><ol><li>Generate root key on offline system</li><li>Create self-signed root certificate</li><li>Apply constraints before any issuance</li><li>Back up root key (encrypted, multiple locations)</li><li>Document recovery process</li><li>Test recovery process</li><li>Store root key offline</li></ol><p>If you want a minimal OpenSSL ceremony (offline root, online intermediate), this is the rough shape:</p><p>Generate a root CA key (offline):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>umask <span style=color:#ae81ff>077</span>
</span></span><span style=display:flex><span>openssl genpkey -algorithm EC -pkeyopt ec_paramgen_curve:P-256 -out root-ca.key
</span></span></code></pre></div><p>Create a self-signed root certificate (offline):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>openssl req -x509 -new -sha256 <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  -key root-ca.key <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  -days <span style=color:#ae81ff>7300</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  -subj <span style=color:#e6db74>&#34;/C=GB/O=Example Ltd/CN=Example Root CA&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  -out root-ca.crt
</span></span></code></pre></div><p>Generate an intermediate key (online):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>umask <span style=color:#ae81ff>077</span>
</span></span><span style=display:flex><span>openssl genpkey -algorithm EC -pkeyopt ec_paramgen_curve:P-256 -out intermediate.key
</span></span></code></pre></div><p>Create an intermediate CSR (online):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>openssl req -new -sha256 <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  -key intermediate.key <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  -subj <span style=color:#e6db74>&#34;/C=GB/O=Example Ltd/CN=Example Issuing CA (prod)&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  -out intermediate.csr
</span></span></code></pre></div><p>Sign the intermediate with the root (offline), applying constraints:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>openssl x509 -req -sha256 <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  -in intermediate.csr <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  -CA root-ca.crt <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  -CAkey root-ca.key <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  -CAcreateserial <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  -days <span style=color:#ae81ff>1825</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  -extfile intermediate.ext <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  -out intermediate.crt
</span></span></code></pre></div><p>This is not a full CA setup. It&rsquo;s enough to show the guardrails in the certificate itself. If you&rsquo;re going to run OpenSSL as your CA, use a proper <code>openssl ca</code> config and database and script the whole thing.</p><p>For intermediates:</p><ul><li>Can be generated online</li><li>Protected by HSM or KMS</li><li>Automated if using managed services</li><li>Still requires secure backup</li></ul><h2 id=monitoring-and-maintenance>Monitoring and Maintenance<a href=#monitoring-and-maintenance class=hanchor arialabel=Anchor>#</a></h2><p><strong>What to monitor:</strong></p><ul><li>Certificate expiry (30 days, 7 days, 1 day warnings)</li><li>Failed renewal attempts</li><li>Revocation list size (growing unexpectedly?)</li><li>OCSP responder availability</li><li>Certificate issuance rate (anomaly detection)</li><li>Name constraint violations (should be zero)</li></ul><p><strong>Regular maintenance:</strong></p><ul><li>Review issued certificates (monthly)</li><li>Audit name constraints (quarterly)</li><li>Test revocation process (quarterly)</li><li>Update CRLs (daily or on-demand)</li><li>Rotate intermediate keys (every 2-3 years)</li><li>Review and update documentation (annually)</li></ul><h3 id=revocation-that-people-actually-use>Revocation That People Actually Use<a href=#revocation-that-people-actually-use class=hanchor arialabel=Anchor>#</a></h3><p>Most internal environments don&rsquo;t do revocation well. The usual story is &ldquo;we&rsquo;ll just wait for expiry&rdquo; - right up until a key leaks and you need it now.</p><p>If you&rsquo;re running an OpenSSL-based CA, CRLs are the least bad option.</p><p>The moving parts you need:</p><ul><li>A published CRL URL (HTTP(S) somewhere stable)</li><li>Certificates that include that CRL distribution point</li><li>A process that updates the CRL often enough that &ldquo;revoke&rdquo; means something</li></ul><p>Example OpenSSL commands (requires you to be using <code>openssl ca</code> with an index/database):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># Revoke a leaf certificate</span>
</span></span><span style=display:flex><span>openssl ca -config ca.cnf -revoke certs/service.crt
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Generate an updated CRL</span>
</span></span><span style=display:flex><span>openssl ca -config ca.cnf -gencrl -out crl/intermediate.crl
</span></span></code></pre></div><p>Then publish <code>crl/intermediate.crl</code> at a predictable URL (for example <code>https://pki.internal/crl/intermediate.crl</code>) and include it in issued certs:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-ini data-lang=ini><span style=display:flex><span><span style=color:#75715e># ca.cnf (snippet)</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>crlDistributionPoints</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>URI:https://pki.internal/crl/intermediate.crl</span>
</span></span></code></pre></div><p>If you don&rsquo;t publish CRLs, or you publish them once a month, revocation is theatre.</p><h2 id=when-things-go-wrong>When Things Go Wrong<a href=#when-things-go-wrong class=hanchor arialabel=Anchor>#</a></h2><h3 id=compromised-private-key>Compromised Private Key<a href=#compromised-private-key class=hanchor arialabel=Anchor>#</a></h3><ol><li>Revoke certificate immediately</li><li>Add to CRL/update OCSP</li><li>Issue new certificate with new key</li><li>Investigate how compromise occurred</li><li>Review other certificates for similar exposure</li></ol><h3 id=expired-root-certificate>Expired Root Certificate<a href=#expired-root-certificate class=hanchor arialabel=Anchor>#</a></h3><p>This is bad. Really bad.</p><p>If your root CA expires:</p><ul><li>All certificates become invalid</li><li>All intermediates become invalid</li><li>Everything breaks simultaneously</li></ul><p><strong>Prevention:</strong></p><ul><li>Root CA validity: 20+ years</li><li>Calendar reminders 5 years before expiry</li><li>Documented renewal process</li><li>Test renewal process in staging</li></ul><p><strong>If it happens:</strong></p><ul><li>Generate new root (different key)</li><li>Issue new intermediates</li><li>Re-issue all leaf certificates</li><li>Update trust stores everywhere</li><li>Pain and suffering</li></ul><h3 id=lost-private-key>Lost Private Key<a href=#lost-private-key class=hanchor arialabel=Anchor>#</a></h3><p>If you lose the CA private key:</p><ul><li>Can&rsquo;t issue new certificates</li><li>Can&rsquo;t revoke certificates</li><li>Can&rsquo;t sign CRLs</li><li>Need to start over with new CA</li></ul><p><strong>Prevention:</strong></p><ul><li>Multiple encrypted backups</li><li>Stored in different physical locations</li><li>Documented recovery process</li><li>Regular recovery testing (actually restore from backup)</li></ul><h2 id=compliance-and-audit>Compliance and Audit<a href=#compliance-and-audit class=hanchor arialabel=Anchor>#</a></h2><p>Even for internal PKI, document your practices:</p><p><strong>Minimum documentation:</strong></p><ul><li>Certificate policy (CP)</li><li>Certificate practice statement (CPS)</li><li>Key generation procedures</li><li>Certificate issuance procedures</li><li>Revocation procedures</li><li>Key storage and protection</li><li>Disaster recovery plan</li></ul><p>Not because auditors demand it (they might). Because future-you will need it when something breaks.</p><h2 id=summary>Summary<a href=#summary class=hanchor arialabel=Anchor>#</a></h2><p>Building internal PKI properly requires:</p><ol><li><strong>Name constraints</strong> - Lock CA to internal namespaces</li><li><strong>EKU/KU restrictions</strong> - One purpose per certificate</li><li><strong>Path length limits</strong> - Prevent uncontrolled sub-CAs</li><li><strong>Short validity</strong> - 30-90 days for leaf certificates</li><li><strong>Automation</strong> - Manual renewal doesn&rsquo;t scale</li><li><strong>Revocation</strong> - CRL or OCSP that actually works</li><li><strong>Monitoring</strong> - Know when certificates expire</li><li><strong>Inventory</strong> - Track every issued certificate</li><li><strong>Documentation</strong> - Future-you will thank present-you</li></ol><p><strong>Don&rsquo;t:</strong></p><ul><li>Use wildcard certificates everywhere</li><li>Store private keys in git</li><li>Skip name constraints</li><li>Manually renew certificates</li><li>Assume &ldquo;internal&rdquo; means &ldquo;low risk&rdquo;</li></ul><p><strong>Do:</strong></p><ul><li>Apply same rigor as Web PKI</li><li>Automate everything possible</li><li>Use modern tooling (Smallstep, Vault, managed services)</li><li>Test disaster recovery</li><li>Document everything</li></ul><p>Internal PKI isn&rsquo;t hard because of cryptography. It&rsquo;s hard because of operational discipline.</p><p>Most organizations skip the guardrails, hoping they won&rsquo;t need them. Then they need them. Then it&rsquo;s too late.</p><p>Build your internal CA properly from the start. Future-you will appreciate it.</p><hr><p><em>Based on building and operating internal PKI at organizations ranging from startups to global banks. The mistakes are real. The fixes work.</em></p></div></div><div class=related-posts style="margin-top:3rem;padding-top:2rem;border-top:1px solid #333"><h3>Related Posts</h3><ul style=list-style:none;padding:0><li style=margin-bottom:1rem><a href=https://gazsecops.github.io/posts/stepca-running-internal-pki/>Smallstep step-ca: Running Internal PKI Without Losing Your Mind</a>
<span style=color:#999;font-size:.9rem>- 28 Oct 2025</span><div style=font-size:.85rem;color:#666;margin-top:.25rem><span style=margin-right:.5rem>#security</span>
<span style=margin-right:.5rem>#pki</span>
<span style=margin-right:.5rem>#tls</span>
<span style=margin-right:.5rem>#certificates</span>
<span style=margin-right:.5rem>#linux</span>
<span style=margin-right:.5rem>#cloud</span>
<span style=margin-right:.5rem>#operations</span></div></li><li style=margin-bottom:1rem><a href=https://gazsecops.github.io/posts/security-as-code-beyond-scanning/>Beyond Scanning: What Security as Code Really Means</a>
<span style=color:#999;font-size:.9rem>- 22 Nov 2025</span><div style=font-size:.85rem;color:#666;margin-top:.25rem><span style=margin-right:.5rem>#security</span>
<span style=margin-right:.5rem>#devsecops</span>
<span style=margin-right:.5rem>#automation</span>
<span style=margin-right:.5rem>#culture</span>
<span style=margin-right:.5rem>#operations</span></div></li><li style=margin-bottom:1rem><a href=https://gazsecops.github.io/posts/penetration-testing-what-works/>Penetration Testing: What Actually Works vs What You Usually Get</a>
<span style=color:#999;font-size:.9rem>- 20 Nov 2025</span><div style=font-size:.85rem;color:#666;margin-top:.25rem><span style=margin-right:.5rem>#security</span>
<span style=margin-right:.5rem>#penetration-testing</span>
<span style=margin-right:.5rem>#red-team</span>
<span style=margin-right:.5rem>#operations</span>
<span style=margin-right:.5rem>#assessment</span></div></li><li style=margin-bottom:1rem><a href=https://gazsecops.github.io/posts/supply-chain-attacks-how-they-happen/>Supply Chain Attacks: How They Happen and What Actually Works to Stop Them</a>
<span style=color:#999;font-size:.9rem>- 10 Nov 2025</span><div style=font-size:.85rem;color:#666;margin-top:.25rem><span style=margin-right:.5rem>#security</span>
<span style=margin-right:.5rem>#supply-chain</span>
<span style=margin-right:.5rem>#dependencies</span>
<span style=margin-right:.5rem>#vulnerabilities</span></div></li><li style=margin-bottom:1rem><a href=https://gazsecops.github.io/posts/oauth2-vs-saml-differences/>OAuth2 vs SAML: Which One and Why?</a>
<span style=color:#999;font-size:.9rem>- 10 Nov 2025</span><div style=font-size:.85rem;color:#666;margin-top:.25rem><span style=margin-right:.5rem>#authentication</span>
<span style=margin-right:.5rem>#oauth2</span>
<span style=margin-right:.5rem>#saml</span>
<span style=margin-right:.5rem>#security</span>
<span style=margin-right:.5rem>#enterprise</span></div></li></ul></div><div class=pagination><div class=pagination__title><span class=pagination__title-h></span><hr></div><div class=pagination__buttons><a href=https://gazsecops.github.io/posts/stepca-running-internal-pki/ class="button inline prev">&lt; [<span class=button__text>Smallstep step-ca: Running Internal PKI Without Losing Your Mind</span>]
</a>::
<a href=https://gazsecops.github.io/posts/security-as-code/ class="button inline next">[<span class=button__text>Security as Code: From Checklists to Automation</span>] ></a></div></div></article></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2026</span></div><div class=build-info><span class=build-commit>e733073</span><span class=build-date>2026-02-12 12:33 UTC</span></div></div></footer></div></body></html>