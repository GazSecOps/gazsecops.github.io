<!doctype html><html lang=en><head><title>Confidential Computing: Processing Data While Keeping It Secret :: Gareth's Engineering Blog</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content=" CISO: Our data never leaves the network. Encrypted at rest, encrypted in transit. We&rsquo;re covered.
Engineer: What happens when we need to process it?
CISO: We decrypt it, process it, encrypt it again. Standard procedure.
Engineer: What if we could process it without ever decrypting it?
CISO: Impossible. You can&rsquo;t do math on encrypted data.
&#34;The revolution isn't preventing access to data. It's processing data you never access.&#34; Traditional encryption works by keeping data secret until you need it. Decrypt, process, encrypt again. It&rsquo;s worked for decades. But it has a fundamental limitation: at some point, the data must be exposed in plaintext.
Confidential computing flips this on its head. Instead of protecting data by controlling who can access it, we protect data by ensuring it&rsquo;s never accessible in plaintext at all. Even during processing.
This isn&rsquo;t theoretical. Companies are using it today. Financial analytics on encrypted transactions. Healthcare processing without seeing patient records. Collaborative fraud detection between competitors without sharing raw data.
"><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://gazsecops.github.io/posts/confidential-computing-encrypted-data-processing/><link rel=stylesheet href=https://gazsecops.github.io/css/extended.min.c658c723e006469d82f697e19c5338967fad12c57650bdd915bacf9cfbe2cc38.css><link rel=stylesheet href=https://gazsecops.github.io/css/buttons.min.86f6b4c106b6c6eb690ae5203d36b442c1f66f718ff4e8164fa86cf6c61ad641.css><link rel=stylesheet href=https://gazsecops.github.io/css/code.min.d529ea4b2fb8d34328d7d31afc5466d5f7bc2f0bc9abdd98b69385335d7baee4.css><link rel=stylesheet href=https://gazsecops.github.io/css/fonts.min.5bb7ed13e1d00d8ff39ea84af26737007eb5051b157b86fc24487c94f3dc8bbe.css><link rel=stylesheet href=https://gazsecops.github.io/css/footer.min.eb8dfc2c6a7eafa36cd3ba92d63e69e849e2200e0002a228d137f236b09ecd75.css><link rel=stylesheet href=https://gazsecops.github.io/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css><link rel=stylesheet href=https://gazsecops.github.io/css/header.min.75c7eb0e2872d95ff48109c6647d0223a38db52e2561dd87966eb5fc7c6bdac6.css><link rel=stylesheet href=https://gazsecops.github.io/css/main.min.36833afd348409fc6c3d09d0897c5833d9d5bf1ff31f5e60ea3ee42ce2b1268c.css><link rel=stylesheet href=https://gazsecops.github.io/css/menu.min.3c17467ebeb3d38663dce68f71f519901124fa5cbb4519b2fb0667a21e9aca39.css><link rel=stylesheet href=https://gazsecops.github.io/css/pagination.min.bbb986dbce00a5ce5aca0504b7925fc1c581992a4bf57f163e5d69cc1db7d836.css><link rel=stylesheet href=https://gazsecops.github.io/css/post.min.e6dddd258e64c83e05cec0cd49c05216742d42fc8ecbfbe6b67083412b609bd3.css><link rel=stylesheet href=https://gazsecops.github.io/css/syntax.min.a0773cce9310cb6d8ed23e50f005448facf29a53001b57e038828daa466b25c0.css><link rel=stylesheet href=https://gazsecops.github.io/css/terminal.min.e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css><link rel=stylesheet href=https://gazsecops.github.io/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css><link rel="shortcut icon" href=https://gazsecops.github.io/favicon.png><link rel=apple-touch-icon href=https://gazsecops.github.io/apple-touch-icon.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Confidential Computing: Processing Data While Keeping It Secret"><meta property="og:description" content=" CISO: Our data never leaves the network. Encrypted at rest, encrypted in transit. We&rsquo;re covered.
Engineer: What happens when we need to process it?
CISO: We decrypt it, process it, encrypt it again. Standard procedure.
Engineer: What if we could process it without ever decrypting it?
CISO: Impossible. You can&rsquo;t do math on encrypted data.
&#34;The revolution isn't preventing access to data. It's processing data you never access.&#34; Traditional encryption works by keeping data secret until you need it. Decrypt, process, encrypt again. It&rsquo;s worked for decades. But it has a fundamental limitation: at some point, the data must be exposed in plaintext.
Confidential computing flips this on its head. Instead of protecting data by controlling who can access it, we protect data by ensuring it&rsquo;s never accessible in plaintext at all. Even during processing.
This isn&rsquo;t theoretical. Companies are using it today. Financial analytics on encrypted transactions. Healthcare processing without seeing patient records. Collaborative fraud detection between competitors without sharing raw data.
"><meta property="og:url" content="https://gazsecops.github.io/posts/confidential-computing-encrypted-data-processing/"><meta property="og:site_name" content="Gareth's Engineering Blog"><meta property="og:image" content="https://gazsecops.github.io/og-image.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><meta property="article:published_time" content="2025-03-01 10:00:00 +0000 UTC"></head><body><div class="container center"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>gareth@blog:~$</div></a></div><div class=header__search><input type=text id=header-search placeholder="Quick search..." style="padding:5px 10px;background:#222;color:#eee;border:1px solid #444;border-radius:3px;font-size:14px;width:200px"></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/topics/>Topics</a></li><li><a href=/posts/>All</a></li><li><a href=/series/>Series</a></li><li><a href=/tags/>Tags</a></li><li><a href=/archive/>Archive</a></li><li><a href=/search/>Search</a></li><li><a href=/about/>About</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/topics/>Topics</a></li><li><a href=/posts/>All</a></li><li><a href=/series/>Series</a></li><li><a href=/tags/>Tags</a></li><li><a href=/archive/>Archive</a></li><li><a href=/search/>Search</a></li><li><a href=/about/>About</a></li></ul></nav></header><script>(function(){const e=document.getElementById("header-search");if(!e)return;e.addEventListener("keydown",function(e){if(e.key==="Enter"){const e=this.value.trim();e&&(window.location.href="/search?q="+encodeURIComponent(e))}}),document.addEventListener("keydown",function(t){t.key==="/"&&!["INPUT","TEXTAREA"].includes(t.target.tagName)&&(t.preventDefault(),e.focus()),t.key==="Escape"&&t.target===e&&e.blur()})})()</script><style>.header__inner{display:flex;align-items:center;gap:20px}.header__search{flex:none}#header-search::placeholder{color:#666;font-style:italic}#header-search:focus{outline:none;border-color:#888}@media(max-width:684px){.header__search{display:none}}</style><div class=content><article class=post><h1 class=post-title><a href=https://gazsecops.github.io/posts/confidential-computing-encrypted-data-processing/>Confidential Computing: Processing Data While Keeping It Secret</a></h1><div class=post-meta><time class=post-date>2025-03-01</time><span class=post-author>Gareth</span><span class=post-reading-time>10 min read (2050 words)</span></div><span class=post-tags>#<a href=https://gazsecops.github.io/tags/security/>security</a>&nbsp;
#<a href=https://gazsecops.github.io/tags/confidential-computing/>confidential-computing</a>&nbsp;
#<a href=https://gazsecops.github.io/tags/encryption/>encryption</a>&nbsp;
#<a href=https://gazsecops.github.io/tags/privacy/>privacy</a>&nbsp;
#<a href=https://gazsecops.github.io/tags/homomorphic-encryption/>homomorphic-encryption</a>&nbsp;</span><div class=table-of-contents><h2>Table of Contents</h2><nav id=TableOfContents><ul><li><a href=#what-confidential-computing-actually-is>What Confidential Computing Actually Is</a><ul><li><a href=#1-homomorphic-encryption>1. Homomorphic Encryption</a></li><li><a href=#2-secure-enclaves-trusted-execution-environments>2. Secure Enclaves (Trusted Execution Environments)</a></li><li><a href=#3-multi-party-computation-mpc>3. Multi-Party Computation (MPC)</a></li></ul></li><li><a href=#real-world-use-cases>Real-World Use Cases</a><ul><li><a href=#use-case-1-financial-analytics-on-encrypted-transactions>Use Case 1: Financial Analytics on Encrypted Transactions</a></li><li><a href=#use-case-2-healthcare-processing-without-seeing-patient-records>Use Case 2: Healthcare Processing Without Seeing Patient Records</a></li><li><a href=#use-case-3-collaborative-fraud-detection-between-competitors>Use Case 3: Collaborative Fraud Detection Between Competitors</a></li></ul></li><li><a href=#the-killer-feature-compute-on-encrypted-data>The Killer Feature: Compute on Encrypted Data</a></li><li><a href=#practical-implementation>Practical Implementation</a><ul><li><a href=#getting-started-with-microsoft-seal>Getting Started with Microsoft SEAL</a></li><li><a href=#getting-started-with-intel-sgx-enclaves>Getting Started with Intel SGX Enclaves</a></li><li><a href=#getting-started-with-pysyft-reality-check>Getting Started with PySyft (Reality Check)</a></li></ul></li><li><a href=#challenges-and-limitations>Challenges and Limitations</a><ul><li><a href=#performance-overhead>Performance Overhead</a></li><li><a href=#complexity>Complexity</a></li><li><a href=#not-universal>Not Universal</a></li></ul></li><li><a href=#getting-started-strategy>Getting Started Strategy</a><ul><li><a href=#phase-1-proof-of-concept-1-2-weeks>Phase 1: Proof of Concept (1-2 weeks)</a></li><li><a href=#phase-2-real-use-case-4-6-weeks>Phase 2: Real Use Case (4-6 weeks)</a></li><li><a href=#phase-3-production-8-12-weeks>Phase 3: Production (8-12 weeks)</a></li></ul></li><li><a href=#the-honest-truth>The Honest Truth</a></li></ul></nav></div><div class=post-content><div><div class=dialogue><p><span class="speaker speaker-ciso">CISO:</span> Our data never leaves the network. Encrypted at rest, encrypted in transit. We&rsquo;re covered.</p><p><span class="speaker speaker-engineer">Engineer:</span> What happens when we need to process it?</p><p><span class="speaker speaker-ciso">CISO:</span> We decrypt it, process it, encrypt it again. Standard procedure.</p><p><span class="speaker speaker-engineer">Engineer:</span> What if we could process it without ever decrypting it?</p><p><span class="speaker speaker-ciso">CISO:</span> Impossible. You can&rsquo;t do math on encrypted data.</p></div><aside class=pullquote>"The revolution isn't preventing access to data. It's processing data you never access."</aside><p>Traditional encryption works by keeping data secret until you need it. Decrypt, process, encrypt again. It&rsquo;s worked for decades. But it has a fundamental limitation: at some point, the data must be exposed in plaintext.</p><p>Confidential computing flips this on its head. Instead of protecting data by controlling who can access it, we protect data by ensuring it&rsquo;s never accessible in plaintext at all. Even during processing.</p><p>This isn&rsquo;t theoretical. Companies are using it today. Financial analytics on encrypted transactions. Healthcare processing without seeing patient records. Collaborative fraud detection between competitors without sharing raw data.</p><h2 id=what-confidential-computing-actually-is>What Confidential Computing Actually Is<a href=#what-confidential-computing-actually-is class=hanchor arialabel=Anchor>#</a></h2><p>Confidential computing is about processing encrypted data without decrypting it. Three main approaches:</p><h3 id=1-homomorphic-encryption>1. Homomorphic Encryption<a href=#1-homomorphic-encryption class=hanchor arialabel=Anchor>#</a></h3><p>Mathematical encryption that allows computations on ciphertexts that, when decrypted, produce the same result as if you&rsquo;d performed the operation on plaintexts.</p><p><strong>How it works:</strong></p><ul><li>Encrypt data using special cryptographic scheme</li><li>Perform mathematical operations directly on encrypted values</li><li>Decrypt the result</li><li>The decrypted result is mathematically identical to what you&rsquo;d get by decrypting first, then computing</li></ul><p><strong>The breakthrough:</strong>
This has been theoretically possible for decades (Gentry&rsquo;s fully homomorphic encryption proved it in 2009). But it was computationally prohibitive - millions of times slower than normal processing. Recent advances in schemes like CKKS (Cheon-Kim-Kim-Song) made it practical for real-world workloads.</p><p><strong>Tools available today:</strong></p><ul><li><strong>Microsoft SEAL</strong> - C++ library for homomorphic encryption</li><li><strong>TenSEAL</strong> - Python bindings for SEAL</li><li><strong>OpenMined PySyft</strong> - Private ML framework (privacy-preserving ML, MPC-style workflows)</li><li><strong>IBM HElib</strong> - Homomorphic encryption library</li></ul><h3 id=2-secure-enclaves-trusted-execution-environments>2. Secure Enclaves (Trusted Execution Environments)<a href=#2-secure-enclaves-trusted-execution-environments class=hanchor arialabel=Anchor>#</a></h3><p>Hardware-isolated regions of memory where code and data are protected even from the operating system and hypervisor.</p><p><strong>How it works:</strong></p><ul><li>CPU creates encrypted memory region (enclave)</li><li>Only code running inside enclave can decrypt data</li><li>CPU validates code integrity before allowing execution</li><li>External observers (even OS, hypervisor, cloud provider) cannot see inside</li></ul><p><strong>Real-world implementations:</strong></p><ul><li><strong>Intel SGX</strong> - Software Guard Extensions</li><li><strong>AMD SEV</strong> - Secure Encrypted Virtualization</li><li><strong>AWS Nitro Enclaves</strong> - Isolated VMs in AWS</li><li><strong>Google Confidential VMs</strong> - AMD SEV-based GCP offering</li><li><strong>Azure Confidential Computing</strong> - Multiple TEE options</li></ul><h3 id=3-multi-party-computation-mpc>3. Multi-Party Computation (MPC)<a href=#3-multi-party-computation-mpc class=hanchor arialabel=Anchor>#</a></h3><p>Multiple parties jointly compute a function over their inputs while keeping those inputs private. No single party ever sees another&rsquo;s data.</p><p><strong>How it works:</strong></p><ul><li>Each participant splits their data into shares</li><li>Shares distributed among participants</li><li>Computation performed on shares, not raw data</li><li>Final result reconstructed only when all parties combine their output shares</li><li>No single share reveals anything about original data</li></ul><p><strong>Use cases:</strong></p><ul><li>Joint fraud detection between banks (without sharing customer data)</li><li>Clinical trials across hospitals (without exposing patient records)</li><li>Salary surveys (without revealing individual salaries)</li><li>Auctions (without revealing bids)</li></ul><h2 id=real-world-use-cases>Real-World Use Cases<a href=#real-world-use-cases class=hanchor arialabel=Anchor>#</a></h2><h3 id=use-case-1-financial-analytics-on-encrypted-transactions>Use Case 1: Financial Analytics on Encrypted Transactions<a href=#use-case-1-financial-analytics-on-encrypted-transactions class=hanchor arialabel=Anchor>#</a></h3><p><strong>Problem:</strong> Bank wants to analyze transaction patterns for fraud detection, but cannot expose customer data due to strict regulations (GDPR, PSD2).</p><p><strong>Traditional approach:</strong> Decrypt all transactions, run analytics, hope nobody leaks data.</p><p><strong>Confidential computing approach:</strong></p><ol><li>Transactions remain encrypted at all times</li><li>Fraud detection model runs on encrypted transactions using homomorphic encryption</li><li>Only flagged transactions are flagged (with proper warrants for decryption if needed)</li></ol><p><strong>Benefits:</strong></p><ul><li>Regulatory compliance built in</li><li>Reduced attack surface (plaintext never exists)</li><li>Can outsource analytics to third parties without data exposure</li><li>Audit trail shows data was never decrypted</li></ul><p><strong>Tools:</strong> Microsoft SEAL + custom fraud detection algorithms</p><h3 id=use-case-2-healthcare-processing-without-seeing-patient-records>Use Case 2: Healthcare Processing Without Seeing Patient Records<a href=#use-case-2-healthcare-processing-without-seeing-patient-records class=hanchor arialabel=Anchor>#</a></h3><p><strong>Problem:</strong> Hospital wants to use AI for diagnosis, but cannot share patient records with external AI vendors due to HIPAA and patient privacy laws.</p><p><strong>Traditional approach:</strong> Anonymize data (often insufficient), send to vendor, hope nobody re-identifies patients.</p><p><strong>Confidential computing approach:</strong></p><ol><li>Patient records encrypted and sent to secure enclave</li><li>AI model runs inside enclave on encrypted data</li><li>Only diagnosis output leaves enclave</li><li>Hospital receives encrypted diagnosis, decrypts locally</li></ol><p><strong>Benefits:</strong></p><ul><li>HIPAA compliance by design</li><li>Vendor never sees patient data (even in plaintext inside enclave)</li><li>Enables use of third-party AI models without data sharing</li><li>Patients can verify their data was never exposed</li></ul><p><strong>Tools:</strong> Intel SGX enclaves + TensorFlow/PyTorch support</p><h3 id=use-case-3-collaborative-fraud-detection-between-competitors>Use Case 3: Collaborative Fraud Detection Between Competitors<a href=#use-case-3-collaborative-fraud-detection-between-competitors class=hanchor arialabel=Anchor>#</a></h3><p><strong>Problem:</strong> Multiple banks want to detect fraud rings that span institutions, but cannot share customer data with competitors.</p><p><strong>Traditional approach:</strong> Nothing. Data silos prevent collaboration. Fraud rings exploit this.</p><p><strong>Confidential computing approach:</strong></p><ol><li>Each bank encrypts their transaction data</li><li>Using MPC, banks jointly run fraud detection algorithm</li><li>No bank ever sees another&rsquo;s raw data</li><li>Only cross-institutional fraud patterns are identified</li></ol><p><strong>Benefits:</strong></p><ul><li>Detects fraud rings that span institutions</li><li>Zero data sharing between competitors</li><li>Regulatory compliant (no customer data leaves bank)</li><li>Collective intelligence without collective exposure</li></ul><p><strong>Tools:</strong> OpenMined PySyft + custom MPC protocols</p><h2 id=the-killer-feature-compute-on-encrypted-data>The Killer Feature: Compute on Encrypted Data<a href=#the-killer-feature-compute-on-encrypted-data class=hanchor arialabel=Anchor>#</a></h2><p>Here&rsquo;s why this matters:</p><p><strong>Traditional encryption:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-fallback data-lang=fallback><span style=display:flex><span>Decrypt → Process → Encrypt
</span></span><span style=display:flex><span>     ↑         ↓
</span></span><span style=display:flex><span>  Exposure happens here
</span></span></code></pre></div><p><strong>Confidential computing:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-fallback data-lang=fallback><span style=display:flex><span>Process on encrypted data
</span></span><span style=display:flex><span>     ↓
</span></span><span style=display:flex><span>  No exposure at any point
</span></span></code></pre></div><p>This isn&rsquo;t just incremental security. It&rsquo;s a paradigm shift.</p><p><strong>Before:</strong> Security was about controlling who could access data (access control, encryption keys, secure networks).</p><p><strong>Now:</strong> Security is about never exposing data in plaintext at all, regardless of who wants to access it.</p><p>The data stays secret. You still get useful results. The mathematics of encryption and the isolation of hardware make it possible to compute without knowing.</p><h2 id=practical-implementation>Practical Implementation<a href=#practical-implementation class=hanchor arialabel=Anchor>#</a></h2><h3 id=getting-started-with-microsoft-seal>Getting Started with Microsoft SEAL<a href=#getting-started-with-microsoft-seal class=hanchor arialabel=Anchor>#</a></h3><p>Microsoft SEAL is probably the easiest entry point into homomorphic encryption. C++ library with Python bindings (TenSEAL) and excellent documentation.</p><p><strong>Install:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>pip install tenseal
</span></span><span style=display:flex><span><span style=color:#75715e># or compile SEAL from source for C++</span>
</span></span></code></pre></div><p><strong>Basic example: Computing average of encrypted numbers</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> tenseal <span style=color:#66d9ef>as</span> ts
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Setup encryption parameters</span>
</span></span><span style=display:flex><span>context <span style=color:#f92672>=</span> ts<span style=color:#f92672>.</span>context(
</span></span><span style=display:flex><span>    ts<span style=color:#f92672>.</span>SCHEME_TYPE<span style=color:#f92672>.</span>CKKS,
</span></span><span style=display:flex><span>    poly_modulus_degree<span style=color:#f92672>=</span><span style=color:#ae81ff>8192</span>,
</span></span><span style=display:flex><span>    coeff_mod_bit_sizes<span style=color:#f92672>=</span>[<span style=color:#ae81ff>60</span>, <span style=color:#ae81ff>40</span>, <span style=color:#ae81ff>40</span>, <span style=color:#ae81ff>60</span>]
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>context<span style=color:#f92672>.</span>global_scale <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>**</span><span style=color:#ae81ff>40</span>
</span></span><span style=display:flex><span>context<span style=color:#f92672>.</span>generate_galois_keys()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Encrypt some numbers</span>
</span></span><span style=display:flex><span>encoder <span style=color:#f92672>=</span> ts<span style=color:#f92672>.</span>CKKSEncoder(context)
</span></span><span style=display:flex><span>numbers <span style=color:#f92672>=</span> [<span style=color:#ae81ff>10.5</span>, <span style=color:#ae81ff>20.3</span>, <span style=color:#ae81ff>30.1</span>, <span style=color:#ae81ff>40.9</span>, <span style=color:#ae81ff>50.2</span>]
</span></span><span style=display:flex><span>encrypted <span style=color:#f92672>=</span> ts<span style=color:#f92672>.</span>ckks_vector(context, numbers)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Compute sum (homomorphic addition)</span>
</span></span><span style=display:flex><span>encrypted_sum <span style=color:#f92672>=</span> encrypted<span style=color:#f92672>.</span>sum()
</span></span><span style=display:flex><span>sum_result <span style=color:#f92672>=</span> encrypted_sum<span style=color:#f92672>.</span>decrypt()[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Compute average (homomorphic division)</span>
</span></span><span style=display:flex><span>num_elements <span style=color:#f92672>=</span> len(numbers)
</span></span><span style=display:flex><span>encrypted_average <span style=color:#f92672>=</span> encrypted_sum <span style=color:#f92672>/</span> num_elements
</span></span><span style=display:flex><span>average_result <span style=color:#f92672>=</span> encrypted_average<span style=color:#f92672>.</span>decrypt()[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Sum: </span><span style=color:#e6db74>{</span>sum_result<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)       <span style=color:#75715e># 152.0</span>
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Average: </span><span style=color:#e6db74>{</span>average_result<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>) <span style=color:#75715e># 30.4</span>
</span></span></code></pre></div><p><strong>What&rsquo;s happening:</strong></p><ul><li>Numbers are encrypted</li><li>Sum and average computed on encrypted values</li><li>Results decrypted only at the end</li><li>Plaintext numbers never exposed during computation</li></ul><h3 id=getting-started-with-intel-sgx-enclaves>Getting Started with Intel SGX Enclaves<a href=#getting-started-with-intel-sgx-enclaves class=hanchor arialabel=Anchor>#</a></h3><p>SGX enclaves require Intel SGX-capable hardware and some setup, but once running, they&rsquo;re straightforward to use.</p><p><strong>Prerequisites:</strong></p><ul><li>Intel SGX-capable CPU</li><li>SGX driver installed</li><li>Intel SGX SDK</li><li>Docker with SGX support</li></ul><p><strong>Basic enclave example (illustrative):</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// enclave.edl - Enclave Definition File
</span></span></span><span style=display:flex><span>enclave {
</span></span><span style=display:flex><span>    trusted {
</span></span><span style=display:flex><span>        public <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>process_sensitive_data</span>([in, out, size<span style=color:#f92672>=</span>len] <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> data, <span style=color:#66d9ef>size_t</span> len);
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    untrusted {
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// enclave.c - Code running inside enclave
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;enclave_t.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>process_sensitive_data</span>(<span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> data, <span style=color:#66d9ef>size_t</span> len) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// This runs inside encrypted memory
</span></span></span><span style=display:flex><span>    <span style=color:#75715e>// OS cannot see what&#39;s happening here
</span></span></span><span style=display:flex><span>    <span style=color:#75715e>// Even hypervisor cannot see inside
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Toy example: reverse the input buffer in-place
</span></span></span><span style=display:flex><span>    <span style=color:#75715e>// Real-world: the hard part is key handling and attestation, not string tricks.
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>size_t</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> len <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>char</span> tmp <span style=color:#f92672>=</span> data[i];
</span></span><span style=display:flex><span>        data[i] <span style=color:#f92672>=</span> data[len <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>-</span> i];
</span></span><span style=display:flex><span>        data[len <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>-</span> i] <span style=color:#f92672>=</span> tmp;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Result leaves enclave as output
</span></span></span><span style=display:flex><span>    <span style=color:#75715e>// Input data stays encrypted and inaccessible
</span></span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// app.c - Untrusted application
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;enclave_u.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;sgx_urts.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>sgx_enclave_id_t</span> eid;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>sgx_launch_token_t</span> token <span style=color:#f92672>=</span> {<span style=color:#ae81ff>0</span>};
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> updated <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Create enclave
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>sgx_status_t</span> status <span style=color:#f92672>=</span> <span style=color:#a6e22e>sgx_create_enclave</span>(
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;enclave.signed.so&#34;</span>,
</span></span><span style=display:flex><span>        SGX_DEBUG_FLAG,
</span></span><span style=display:flex><span>        <span style=color:#f92672>&amp;</span>token,
</span></span><span style=display:flex><span>        <span style=color:#f92672>&amp;</span>updated,
</span></span><span style=display:flex><span>        <span style=color:#f92672>&amp;</span>eid,
</span></span><span style=display:flex><span>        NULL
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (status <span style=color:#f92672>!=</span> SGX_SUCCESS) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Failed to create enclave: 0x%x</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, status);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Data to process
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> sensitive_data[] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;This is sensitive&#34;</span>;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Send to enclave for processing
</span></span></span><span style=display:flex><span>    status <span style=color:#f92672>=</span> <span style=color:#a6e22e>process_sensitive_data</span>(eid, sensitive_data, <span style=color:#a6e22e>strlen</span>(sensitive_data));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (status <span style=color:#f92672>!=</span> SGX_SUCCESS) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;ECALL failed: 0x%x</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, status);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>sgx_destroy_enclave</span>(eid);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Result: %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, sensitive_data);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Data was processed inside enclave
</span></span></span><span style=display:flex><span>    <span style=color:#75715e>// Never exposed in plaintext outside enclave
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>sgx_destroy_enclave</span>(eid);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Key point:</strong> Everything in <code>enclave.c</code> runs in encrypted memory. The application in <code>app.c</code> can call it, but cannot see inside.</p><h3 id=getting-started-with-pysyft-reality-check>Getting Started with PySyft (Reality Check)<a href=#getting-started-with-pysyft-reality-check class=hanchor arialabel=Anchor>#</a></h3><p>If you&rsquo;ve seen PySyft examples using <code>TorchHook</code>, <code>VirtualWorker</code>, and <code>.send()</code>, they&rsquo;re from old versions.</p><p>PySyft is still a real project, but the API has moved around over the years. Treat it like a platform you adopt, not a snippet you paste into a notebook.</p><p>The basic workflow you are aiming for looks like this:</p><ol><li>Data stays with each data owner (hospital A, hospital B, etc.)</li><li>You send a training job to each owner (or run it in their environment)</li><li>You only get back what you agreed you can get back (aggregates, gradients, or a trained model)</li><li>You can prove - or at least strongly argue - that raw data never left</li></ol><p>If you want this in production, decide early what you actually need:</p><ul><li>A trained model that never saw raw data</li><li>Aggregated analytics (counts, averages, cohorts)</li><li>Joint detection (&ldquo;is this transaction in your fraud set?&rdquo;)</li></ul><p>Then pick the tool that matches. MPC-style systems tend to be opinionated about deployment and orchestration. That&rsquo;s not a bug.</p><h2 id=challenges-and-limitations>Challenges and Limitations<a href=#challenges-and-limitations class=hanchor arialabel=Anchor>#</a></h2><h3 id=performance-overhead>Performance Overhead<a href=#performance-overhead class=hanchor arialabel=Anchor>#</a></h3><p>Homomorphic encryption is slower than plaintext computation.</p><p><strong>Reality check (ballpark):</strong></p><ul><li>TEEs (enclaves / confidential VMs): often within single-digit to low double-digit percent of native, but you pay in complexity (attestation, images, debugging)</li><li>MPC: depends on number of parties and network. You can make it fast, or you can make it private. Pick one, then compromise.</li><li>Homomorphic encryption: still slow. For anything beyond toy arithmetic, expect orders of magnitude overhead.</li></ul><p><strong>Mitigation:</strong></p><ul><li>Choose right tool for right job (enclaves faster than homomorphic encryption)</li><li>Batch computations when possible</li><li>Use hybrid approaches (encrypt what matters, keep other things normal)</li><li>Leverage hardware acceleration where available</li></ul><h3 id=complexity>Complexity<a href=#complexity class=hanchor arialabel=Anchor>#</a></h3><p>Implementing confidential computing requires specialized knowledge.</p><p><strong>Challenges:</strong></p><ul><li>Cryptographic expertise for homomorphic encryption</li><li>Hardware-specific code for enclaves</li><li>Protocol design for MPC</li><li>Integration with existing systems</li></ul><p><strong>Mitigation:</strong></p><ul><li>Use mature libraries (SEAL, PySyft, etc.)</li><li>Start with use cases where value exceeds complexity cost</li><li>Leverage managed services (AWS Nitro, Azure Confidential Computing)</li><li>Build internal expertise gradually</li></ul><h3 id=not-universal>Not Universal<a href=#not-universal class=hanchor arialabel=Anchor>#</a></h3><p>Confidential computing isn&rsquo;t a silver bullet.</p><p><strong>Doesn&rsquo;t work for:</strong></p><ul><li>All data types (some structures don&rsquo;t map well)</li><li>All algorithms (some require random access patterns incompatible with encryption)</li><li>Real-time systems where latency is critical (yet)</li><li>Workloads where data must be combined from unencrypted sources</li></ul><p><strong>Best for:</strong></p><ul><li>Batch analytics on sensitive data</li><li>ML model training on private datasets</li><li>Cross-organization collaboration</li><li>Regulatory-heavy environments (healthcare, finance)</li></ul><h2 id=getting-started-strategy>Getting Started Strategy<a href=#getting-started-strategy class=hanchor arialabel=Anchor>#</a></h2><h3 id=phase-1-proof-of-concept-1-2-weeks>Phase 1: Proof of Concept (1-2 weeks)<a href=#phase-1-proof-of-concept-1-2-weeks class=hanchor arialabel=Anchor>#</a></h3><p><strong>Goal:</strong> Validate approach with small-scale experiment.</p><p><strong>Actions:</strong></p><ol><li>Choose a toy use case (simple analytics, basic ML)</li><li>Implement with homomorphic encryption (SEAL/TenSEAL)</li><li>Measure performance overhead</li><li>Document learnings</li></ol><p><strong>Success criteria:</strong></p><ul><li>Can you encrypt, compute, decrypt?</li><li>Is performance acceptable for your use case?</li><li>Do you understand the limitations?</li></ul><h3 id=phase-2-real-use-case-4-6-weeks>Phase 2: Real Use Case (4-6 weeks)<a href=#phase-2-real-use-case-4-6-weeks class=hanchor arialabel=Anchor>#</a></h3><p><strong>Goal:</strong> Apply to actual business problem.</p><p><strong>Actions:</strong></p><ol><li>Identify real use case where value exceeds cost</li><li>Choose appropriate technology (homomorphic, enclave, or MPC)</li><li>Implement end-to-end solution</li><li>Integrate with existing systems</li></ol><p><strong>Success criteria:</strong></p><ul><li>Does it solve the problem?</li><li>Is it production-ready (or close)?</li><li>Is regulatory/compliance benefit clear?</li></ul><h3 id=phase-3-production-8-12-weeks>Phase 3: Production (8-12 weeks)<a href=#phase-3-production-8-12-weeks class=hanchor arialabel=Anchor>#</a></h3><p><strong>Goal:</strong> Deploy to production environment.</p><p><strong>Actions:</strong></p><ol><li>Security audit (critical for confidentiality systems)</li><li>Performance optimization</li><li>Monitoring and alerting</li><li>Documentation and training</li></ol><p><strong>Success criteria:</strong></p><ul><li>Running reliably in production</li><li>Teams understand how to use it</li><li>Measurable security benefit</li></ul><h2 id=the-honest-truth>The Honest Truth<a href=#the-honest-truth class=hanchor arialabel=Anchor>#</a></h2><p><strong>Confidential computing isn&rsquo;t for everything.</strong> It adds cost, latency, and operational hassle. You need a reason.</p><p>The reason is usually one of these:</p><ul><li>You&rsquo;re crossing a trust boundary you can&rsquo;t avoid (third-party analytics, shared platforms, multi-tenant stuff)</li><li>The data is too sensitive to ever sit in plaintext in someone else&rsquo;s process</li><li>You&rsquo;re trying to collaborate with someone who will never hand you their raw data (and you won&rsquo;t hand them yours)</li></ul><p>If none of that applies, don&rsquo;t do it. Use normal encryption and normal access controls and spend the time you saved on monitoring and incident response.</p><hr><p><em>Based on production deployments at financial institutions, healthcare organizations, and technology companies. Tools mentioned (Microsoft SEAL, OpenMined PySyft, TenSEAL, Intel SGX, AWS Nitro Enclaves) are all production-ready and actively maintained. The revolution isn&rsquo;t preventing access to data. It&rsquo;s processing data you never access.</em></p></div></div><div class=related-posts style="margin-top:3rem;padding-top:2rem;border-top:1px solid #333"><h3>Related Posts</h3><ul style=list-style:none;padding:0><li style=margin-bottom:1rem><a href=https://gazsecops.github.io/posts/security-as-code-beyond-scanning/>Beyond Scanning: What Security as Code Really Means</a>
<span style=color:#999;font-size:.9rem>- 22 Nov 2025</span><div style=font-size:.85rem;color:#666;margin-top:.25rem><span style=margin-right:.5rem>#security</span>
<span style=margin-right:.5rem>#devsecops</span>
<span style=margin-right:.5rem>#automation</span>
<span style=margin-right:.5rem>#culture</span>
<span style=margin-right:.5rem>#operations</span></div></li><li style=margin-bottom:1rem><a href=https://gazsecops.github.io/posts/penetration-testing-what-works/>Penetration Testing: What Actually Works vs What You Usually Get</a>
<span style=color:#999;font-size:.9rem>- 20 Nov 2025</span><div style=font-size:.85rem;color:#666;margin-top:.25rem><span style=margin-right:.5rem>#security</span>
<span style=margin-right:.5rem>#penetration-testing</span>
<span style=margin-right:.5rem>#red-team</span>
<span style=margin-right:.5rem>#operations</span>
<span style=margin-right:.5rem>#assessment</span></div></li><li style=margin-bottom:1rem><a href=https://gazsecops.github.io/posts/supply-chain-attacks-how-they-happen/>Supply Chain Attacks: How They Happen and What Actually Works to Stop Them</a>
<span style=color:#999;font-size:.9rem>- 10 Nov 2025</span><div style=font-size:.85rem;color:#666;margin-top:.25rem><span style=margin-right:.5rem>#security</span>
<span style=margin-right:.5rem>#supply-chain</span>
<span style=margin-right:.5rem>#dependencies</span>
<span style=margin-right:.5rem>#vulnerabilities</span></div></li><li style=margin-bottom:1rem><a href=https://gazsecops.github.io/posts/oauth2-vs-saml-differences/>OAuth2 vs SAML: Which One and Why?</a>
<span style=color:#999;font-size:.9rem>- 10 Nov 2025</span><div style=font-size:.85rem;color:#666;margin-top:.25rem><span style=margin-right:.5rem>#authentication</span>
<span style=margin-right:.5rem>#oauth2</span>
<span style=margin-right:.5rem>#saml</span>
<span style=margin-right:.5rem>#security</span>
<span style=margin-right:.5rem>#enterprise</span></div></li><li style=margin-bottom:1rem><a href=https://gazsecops.github.io/posts/stepca-running-internal-pki/>Smallstep step-ca: Running Internal PKI Without Losing Your Mind</a>
<span style=color:#999;font-size:.9rem>- 28 Oct 2025</span><div style=font-size:.85rem;color:#666;margin-top:.25rem><span style=margin-right:.5rem>#security</span>
<span style=margin-right:.5rem>#pki</span>
<span style=margin-right:.5rem>#tls</span>
<span style=margin-right:.5rem>#certificates</span>
<span style=margin-right:.5rem>#linux</span>
<span style=margin-right:.5rem>#cloud</span>
<span style=margin-right:.5rem>#operations</span></div></li></ul></div><div class=pagination><div class=pagination__title><span class=pagination__title-h></span><hr></div><div class=pagination__buttons><a href=https://gazsecops.github.io/posts/ssh-hardening-what-actually-matters/ class="button inline prev">&lt; [<span class=button__text>SSH Hardening: What Actually Matters</span>]
</a>::
<a href=https://gazsecops.github.io/posts/bash-security-operators-guide/ class="button inline next">[<span class=button__text>Bash: The Swiss Army Knife for Security Professionals</span>] ></a></div></div></article></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2026</span></div><div class=build-info><span class=build-commit>e733073</span><span class=build-date>2026-02-12 12:33 UTC</span></div></div></footer></div></body></html>